---
show: step
version: 1.0
enable_checker: true
---

# The Designing and Modeling of Bank Queue System

## 1. Introductions

#### 1.1 Content

> On Christmas Day, a bank only opens from 8 am tp 12 am. Suppose the bank only offers service in `w` service windows on that day, let me ask you:
>
> 1. How many customers arrive at the bank per minute?
> 2. How long does it take for one customer to occupy the service window? 

#### 1.2 Knowledge Points

- OOP Programing
- Theory of function `std::rand()`
- Queuing theory
- Data structure of chained queue and implementing its template 
- Design of event-driven 
- Monte Carlo method
- Model of CPU resource competition
- Round robin


## 2. Theory
#### 2.1  Problems to be solved

2.1  Problems to be solved
The Monte Carlo method might sound very hard, but substance of it is use computer to simulate and reproduce the question. In this experiment, we will use the Monte Carlo method to simulate the question of banking queue system:

First, let's analyze the its business logic:

In bank service, all the customers wait for the service by taking a queue number, which is different from buying tickets in the train station. In the case of train station, customers have to queue in a queue of a certain window. Besides, the window cannot be changed, or the customer has to queue in the end again. In other words, as for bank service, all customers queue in the same queue. When a service window is available, a new customer will be extracted from the top of the queue to handle his/her bank business. All in all, while implementing the codes, you can create w windows, however, you only need to implement one customer queue.

 Second, as for customers, 2 properties can be abstracted:

1. Time for arriving at the banks.
2. Time for bank service.

Additionally, these two properties are random. Now, the whole queue model becomes:


![image desc](https://labex.io/upload/V/B/S/5nPO4sh0YWRF.png)


Next, let's analyze the implementation logic of the question in detail, to enable our program to output like this: 


![image desc](https://labex.io/upload/M/S/D/YjgjFjcitnyy.png)


#### 2.2 The Random in Computer

Theory of function `std::rand()`

The random number generated by function `std::rand()` in C++ is not a true random number, as it's not uniformly distributed. In order to make our simulation system more real, we need to learn the theory of function `std::rand()`. 

What `std::rand()` generates is a random binary sequence(which is easier to implement in underlying hardware). The probability of being 0 or 1 for every bit of the sequence is the same. And as for`std::rand()%n`, it will generate a random number between [0, n-1]. Therefore, if the binary value of n-1 is not all consisted of 1, then the numbers in it can't be uniformly distributed(because some bits might not be 1).

So, when and only when the random number in [0, n-1] can be represented by the subsequence of the sequence, it's uniformly distributed. In other words, only when the binary number of n-1 is all consisted of 1, the probability of 1 and 0 are equal.

Let's implement the `random` class first.
Create folder `queuesystem` under the directory `/home/labex/`, and create file `Random.hpp` under this folder: 

```c++
//
//  Random.hpp
//  QueueSystem
//

#ifndef Random_hpp
#define Random_hpp

#include <cstdlib>
#include <cmath>

class Random {
public:
     // The uniformly distributed random value between [0, 1) 
    static double uniform(double max = 1) {
        return ((double)std::rand() / (RAND_MAX))*max;
    }
};
#endif /* Random_hpp */
```

In this method, when we invoke `Random::uniform()`, we can get the true random number that are uniformly distributed. After assigning the arguments, we can generate the random value between [0, max). 

```checker
- name: check if Random.hpp exist
  script: |
    #!/bin/bash
    ls /home/labex/queuesystem/Random.hpp
  error:
      Oops! We found you didn't create file "Random.hpp" in "/home/labex/queuesystem/".
```

## 3. Steps
Next, let's enter the detailed implementing steps of the design and modeling of the system. 

### 3.1 Logic Design of the Main Function

As for a bank, the outside world only needs to offer two parameters:

1. The total service time
2. The number of service windows 

Create `main.cpp` under `/home/labex/queuesystem/` to implement the following codes：

```c++
//
// main.cpp
// QueueSystem
//

#include "QueueSystem.hpp"

#include <iostream>
#include <cstdlib>

int main() {
    
    std::srand((unsigned)std::time(0)); // Use the current time as the random number seed

    int total_service_time = 240;       // Calculate by time 
    int window_num         = 4;
    int simulate_num       = 100000;    //  Number of simulation times
    
    QueueSystem system(total_service_time, window_num);
    system.simulate(simulate_num);
    
    std::cout << "The average time of customer stay in bank: "
              << system.getAvgStayTime() << std::endl;
    std::cout << "The number of customer arrive bank per minute: "
              << system.getAvgCustomers() << std::endl;
    
    return 0;
}
```

```checker
- name: check if main.cpp exist
  script: |
    #!/bin/bash
    ls /home/labex/queuesystem/main.cpp
  error:
    Oops! We found you didn't create file "main.cpp" in "/home/labex/queuesystem/".
- name: check if main exist in main.cpp
  script: |
    #!/bin/bash
    grep -i 'main' /home/LebEx/queuesystem/main.cpp
  error:
    Oops! We found you didn't identify "main" function in "main.cpp".
```

### 3.2  Design of Object and Logic

> To summarize, the things to be implemented are:

1. Class `ServiceWindow` (Create w of it)
2. Class `QueueSystem` (Create only one of it)
3. Customer structure(Containing two random properties: arriving time and service time)

> To better practice C++, we'll give up fast coding standard libraries like vector

According to the description of the question before, we can preliminarily decide the designing requirement of these classes: 

1. Class `QueueSystem` : It makes the simulation of the whole queue.
2. Class `ServiceWindow` : The service window object of queue system. When a bank is created, a service window will be created too. To make the question more flexible, suppose that we need to create `window_num` windows; 
3. Class `Queue` : The queue of customers in bank queue system.
4. Class `Random` : Already discussed chapter 2. 

However, before designing `ServiceWindow`, we need to consider what members should be put into class `ServiceWindow`. First of all, as for a service window, it should have a customer property to store customers. Second, a window only has two states: occupied or available. So, the following enumeration will be in `ServiceWindow`. Create `ServiceWindow.hpp` in `/home/labex/queuesystem/`: 

```c++
//
// ServiceWindow.hpp
// QueueSystem
//

enum WindowStatus {
    SERVICE,
    IDLE,
};
```

Since we are to store customers in `ServiceWindow`, and as the customers don't provide any method, so we can directly design customers as a structure `Customer`. And meanwhile, customers will be a member of the queue, so `Customer` can be called as a `Node` of the queue. What's more, the needed service time for every customer is random, but the arriving time can't be decided by customers(we will talk about in the next course), so the implicit structure of `Customer` structure should be designed. Please create `Node.hpp` under `/home/labex/queuesystem/`.

```c++
//
//  Node.hpp
//  QueueSystem
//

#ifndef Node_hpp
#define Node_hpp

#include "Random.hpp"

#define RANDOM_PARAMETER 100

struct Node {
    int arrive_time;
    int duration;
    struct Node *next;
    
    // The event of arriving is 0 by default, the event of service duration is random 
    Node(int arrive_time = 0,
         int duration = Random::uniform(RANDOM_PARAMETER)):
        arrive_time(arrive_time),
        duration(duration),
        next(NULL) {}
};

typedef struct Node Node;
typedef struct Node Customer;

#endif /* Node_h */

```

So, combining the `WindowStatus` enumeration and `Customer` structure, our `ServiceWindow` class should be designed like this. As the operation of the window is quite easy, for example, setting whether the window is busy, get the arriving time of the customers for the later calculation. So we directly design it as the `inline` function inside the class:

```c++
//
//  ServiceWindow.hpp
//  QueueSystem
//

#ifndef ServiceWindow_hpp
#define ServiceWindow_hpp

#include "Node.hpp"

enum WindowStatus {
    SERVICE,
    IDLE,
};

class ServiceWindow {
public:
    inline ServiceWindow() {
        window_status = IDLE;
    };
    inline bool isIdle() const {
        if (window_status == IDLE) {
            return true;
        } else {
            return false;
        }
    }
    inline void serveCustomer(Customer &customer) {
        this->customer = customer;
    }
    inline void setBusy() {
        window_status = SERVICE;
    }
    inline void setIdle() {
        window_status = IDLE;
    }
    inline int getCustomerArriveTime() const {
        return customer.arrive_time;
    }
    inline int getCustomerDuration() const {
        return customer.duration;
    }
private:
    Customer customer;
    WindowStatus window_status;
};

#endif /* ServiceWindow_hpp */
```

```checker
- name: check if ServiceWindow.hpp exist
  script: |
    #!/bin/bash
    ls /home/LebEx/queuesystem/ServiceWindow.hpp
  error:
     Oops! We found you didn't create file "ServiceWindow.hpp" in "/home/labex/queuesystem/". 
- name: check if Node.hpp exist
  script: |
    #!/bin/bash
    ls /home/LebEx/queuesystem/Node.hpp
  error:
      Oops! We found you didn't create file "Node.hpp" in "/home/labex/queuesystem/".
```

### 3.3 The Design of Event-driven   

With the designs above, it seems that writing the customer queue can be enough to describe the whole queue system. However, there's a big problem in the designs above: The whole system is static. As customers wait in the queue, when does the window serve the next customer? How to deal with the logic inside? We haven't thought about these so far. 

In order to get the system running, we need to think about the running timeline of the whole system. There's a design of event-driven. 

In the analysis before, we know that there're only two events in the system: 

1. Customers arrive.
2. Customers leave.

The second event contains an event, which is, the queue of window service waits for the next customer to come. So, if we can maintain an event list, then we can drive the whole queue system running, because we can inform the queue system to update its state when an event happens.

In summary, we can first design the event structure in the event list.
Create `Event.hpp ` under `/home/labex/queuesystem/`.

```c++
//
//  Event.hpp
//  QueueSystem
//

#ifndef Event_hpp
#define Event_hpp

#include "Random.hpp"
#define RANDOM_PARAMETER 100

struct Event {
    int occur_time;
    
   // Use -1 to express the arriving event, use >=0 for depature event. Meanwhile, the value number means the service window which the customer left 
    int event_type;
    
    Event* next;
    
    // The implicit arriving event, the event happened is random 
    Event(int occur_time = Random::uniform(RANDOM_PARAMETER),
          int event_type = -1):
        occur_time(occur_time),
        event_type(event_type),
        next(NULL) {}
};

#endif /* Event_hpp */
```

We used a little trick here, that is, use integer to represent the type of the event, instead of using enumeration simply. 

That is because, as for `ServiceWindow`. we can use array to manage multiple `ServiceWindow`, so if the corresponding event type is integer, then the event type can be the index subscript of `ServiceWindow` in the same time. Besides, when event_type >= 0 , the value also represents the service window that customers left. 

Additionally, as the event list and customers queue can be classified into a same structure in essence, which is queue. The only difference is their method of entering the queue. As for event list, customers must enter the queue by the time order. And as for customers, they will just be appended to the end of the queue. Considering these, we can easily use the template to design the basic requirement of the queue. Create `Queue.hpp` under `/home/labex/queuesystem/`.  

```c++
//  Queue.hpp
//  QueueSystem
//

#ifndef Queue_hpp
#define Queue_hpp

#include <iostream>
#include <cstdlib>

#include "Event.hpp"

// Queue with head note
template <typename T>
class Queue
{
public:
    Queue();
    ~Queue();
    void clearQueue();             // Clear the queue
    T* enqueue(T &node);
    T* dequeue();
    T* orderEnqueue(Event &event); // Only for the event to enter the queue 
    int  length();
private:
    T *front;  // Head note
    T *rear;   // End of the queue
};
#endif /* Queue_hpp */
```

```checker
- name: check if Event.hpp exist
  script: |
    #!/bin/bash
    ls /home/labex/queuesystem/Event.hpp
  error:
  Oops! We found you didn't create file "Event.hpp" in "/home/labex/queuesystem/". 
- name: check if Queue.hpp exist
  script: |
    #!/bin/bash
    ls /home/labex/queuesystem/Queue.hpp
  error:
    Oops! We found you didn't create file "Queue.hpp" in "/home/labex/queuesystem/".
```

### 3.4 QueueSystem

From the discussion before, we have finished the design of all the basic structures. Based on that, we can preliminarily decide the basic structure of the queue system to implement. 

First, according to the design of the main function, we need two parameters tp initialize the whole queue system:

1. The total service time(minute) `int total_service_time`
2. The number of the service windows `int window_num`

Second, we need at least 3 ports for `QueueSystem`:

1. Simulate `simulate()`
2. Get the average staying time of customers `getAvgStayTime()`
3. Get the average customer number per minute `getAvgCustomers()`

Third, the content in the internal to implement contains: 

1. Initialize before the system runs `init()`
2. Makes the system run `run()`
3. Clear after the system ends running `end()`

Fourth, the core members for the whole system to manage are: 

1. Service window `ServiceWindow* windows`
2. Customer queue `Queue<Customer> customer_list`
3. Event list `Queue<Event> event_list`
4. Current system event `Event* current_event`

Fifth, the method to  events:

1. Process the arriving event of customers `void customerArrived()`
2. Process the departure event of customers `void customerDeparture()`

Last but not least, the average staying time of customers and the average customer number per minute are related to 4 variables： 

1. The total staying time of customers `int total_customer_stay_time`
2. The total customer number one the system runs for one time `int total_customer_num`
3. The average customer number per minute `double avg_customers`
4. The average staying time of customers `double avg_stay_time`

As a matter of fact, we will need a method to process the customer service logic. `getIdleServiceWindow` is used to get the state of the current service window, so that the reusability of the codes will be increased. 

So, `create QueueSystem.hpp` under `/home/labex/queuesystem/`.
The code design of the whole `QueueSystem` class is: 

```cpp
//
//  QueueSystem.hpp
//  QueueSystem
//

#ifndef QueueSystem_hpp
#define QueueSystem_hpp

#include "Event.hpp"
#include "Queue.hpp"
#include "ServiceWindow.hpp"

class QueueSystem {
    
public:
    // Initialize queue system 
    QueueSystem(int total_service_time, int window_num);
    
    // Destroy
    ~QueueSystem();
    
    // Start simulation 
    void simulate(int simulate_num);
    
    inline double getAvgStayTime() const {
        return avg_stay_time;
    }
    inline double getAvgCustomers() const {
        return avg_customers;
    }
    
private:
    // Let the queue system run for one time 
    double run();
    
    // Initialize all the parameters 
    void init();
    
    // Clear all the parameters  
    void end();
    
    // Get the index of all the available windows 
    int getIdleServiceWindow();
    
    // Process the customer arriving event 
    void customerArrived();
    
    // Process the customer depature event 
    void customerDeparture();
    
    // The total number of service windows
    int window_num;
    
    // The total service time 
    int total_service_time;
    
    // The total staying time of customers 
    int total_customer_stay_time;
    
    // Total customer number
    int total_customer_num;
    
    // Core numbers 
    ServiceWindow*  windows;
    Queue<Customer> customer_list;
    Queue<Event>       event_list;
    Event*          current_event;
    
    // The result for external invoking
    double avg_customers;
    double avg_stay_time;

};


#endif /* QueueSystem_hpp */
```

```checker
- name: check if QueueSystem.hpp exist
  script: |
    #!/bin/bash
    ls /home/labex/queuesystem/QueueSystem.hpp
  error:
    Oops! We've found that you didn't create file "QueueSystem.hpp" in "/home/labex/queuesystem/".
```

## 4. Summary

In this part, we designed the basic logic of the whole bank queue system, and referred the idea of event-driven to design the event class of to drive the queue system. The files created in this part are:

1. `Event.hpp`
2. `Node.hpp`
3. `Queue.hpp`
4. `Random.hpp`
5. `ServiceWindow.hpp`
6. `QueueSystem.hpp`
7. `main.cpp`

However, the codes cannot be run directly. In this part, we focus on making our business logic clear. In the next part, we will implement the detailed logic of these codes, including:

1. The detailed implementation of the chained queue template in `Queue.hpp` 
2. The detailed service logic in `QueueSystem.cpp`
3. The more complicated random probability distribution in `Random.hpp` 

In these implementation, we will consolidate the use of the following knowledges: 

1. C++ class template
2. The data structure of chained queue
3. probability programming
