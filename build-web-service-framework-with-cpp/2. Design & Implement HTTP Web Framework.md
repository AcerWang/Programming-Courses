---
show: step
version: 1.0
enable_checker: true
---

# Design & Implement HTTP Web Framework

## 1. Introduction

Web service is the most basic unit of server side development, by abstracting the server side request and response logic, we can shape a web service framework and then achieve the highest level of frame-level code reuse. In this project, C++11 and Boost Asio will be used to implement our HTTP and HTTPS server side framework.

#### Things to Learn

- C++ Basics
- C++11 Related
- Boost Asio Related

## 2. Design

We know that both HTTP and HTTPS are protocols of the application layer, and their underlying layers are actually transmitted over TCP. Therefore, to implement a Web framework, you must make an understanding of the browser's process of accessing the Web server.

First, the server is already running the service, so it starts listening on the port via Socket after the server starts. At this time, when the client browser wants to access the server resources, it sends a corresponding HTTP or HTTPS request. When the server receives the request, it will process this part of the request and return the resources required by the client.

After careful thinking, it is not difficult to find that the only difference between the HTTP and HTTPS servers in handling requests and returning requests lies in how they actually deal with the way the client establishes connections, which is the so called `accept()` method.

Therefore, when designing the base class, we can design the `accept()` method as a virtual function, leaving it to a concrete subclass to implement this method. The real logic related to the server's internals is all from the base class. ServerBase` to achieve.

In this regard, we first determine the basic design of the base class. In the `ServerBase` template class, we only need to reserve an interface `start()` to start the server for external calls.

Since the subclass needs to implement the concrete way of the virtual function `accept()`, it needs to be kept as protected because we need to parse and reply to the request, and this part of the logic is actually irrelevant to the protocol type, so we can use this part The logic is put directly into `ServerBase` for implementation, so far we have (create `server.base.hpp` in `/home/labex/Code`):

```cpp
//
// server.base.hpp
//
#ifndef SERVER_BASE_HPP
#define SERVER_BASE_HPP

#include <boost/asio.hpp>

#include <regex>
#include <unordered_map>
#include <thread>

namespace LabexWeb {

    // socket_type is HTTP or HTTPS
    template <typename socket_type>
    class ServerBase {
    public:
        void start();
    protected:
        // requires to implement this method for different type of server
        virtual void accept() {}

        void process_request_and_respond(std::shared_ptr<socket_type> socket) const;
    };

    template<typename socket_type>
    class Server : public ServerBase<socket_type> {};
}
#endif /* SERVER_BASE_HPP */
```

### 2.1 ServerBase

To implement a web server, the most important thing is to parse the request information from the client. To do this, we need to define a `Request` structure in the `LabexWeb` namespace:

```cpp
namespace LabexWeb {
    struct Request {
        // request method, POST, GET; path; HTTP version
        std::string method, path, http_version;
        // use smart pointer for reference counting of content
        std::shared_ptr<std::istream> content;
        // hash container, key-value dict
        std::unordered_map<std::string, std::string> header;
        // use regular expression for path match
        std::smatch path_match;
    };
}
```

This structure is used to resolve requests such as request methods, request paths, HTTP versions, and more. At the same time, we define a `std::istream` pointer to hold the contents of the request body. Since we don't care about the order of the information in the header, we can consider using `std::unordered_map` to specify an unordered container and save the header. In addition, since the request path needs to be parsed, we might as well use regular expressions to handle this part of the parsing.

After defining the request, we also need to consider the type of server resources. This resource type determines how we can let others use our library. First we define the resource type:

```cpp
namespace LabexWeb {
    typedef std::map<std::string, std::unordered_map<std::string,
    std::function<void(std::ostream&, Request&)>>> resource_type;
}
```

and define the member of `ServerBase`:

```cpp
template <typename socket_type>
class ServerBase {
public:
    resource_type resource;
    resource_type default_resource;
protected:
    std::vector<resource_type::iterator> all_resources;
……
```

First, `resource_type` is a `std::map` whose key is a string and the value is an unordered container `std::unordered_map`. The key of this unordered container is still a string whose value is accepted A function with an empty return type, parameters ostream, and Request.

Therefore, when we use this framework, when we have a `Server` object, the definition resource can use the framework similar to the following:

```cpp
// Process a GET request to /info to return the requested information
server.resource["^/info/?$"]["GET"] = [](ostream& response, Request& request) {
     // Process requests and resources
     // ...
};
```

Among them, `std::map` is used to store the regular expression of the request path, and `std::unordered_map` is used to store the request method, and finally an anonymous Lambda function is used to save the processing method. With resource types, we simply define the interface when others use this framework.

For this reason, we also need to consider the members and methods needed to implement other interfaces.

First, the Boost Asio library requires each application to have a scheduler for the `io_service` object. For TCP socket connections, an `acceptor` object is needed, and an `acceptor` needs to have an `endpoint` object. We need to define it in the `protected` scope of the `ServerBase` class:

```cpp
protected:
    boost::asio::io_service m_io_service;
    boost::asio::ip::tcp::endpoint endpoint;
    boost::asio::ip::tcp::acceptor acceptor;
```

A single-threaded server is useless, so we might as well implement a thread pool internally, so we can continue to define:

```cpp
protected:
    size_t num_threads;
    std::vector<std::thread> threads;
```

The entire `ServerBase` should complete the initialization of some key members when it is constructed. For `endpoint` we can initialize it with `tcp::v4()` and the port number stated, after the completion of the io_service object Together with endpoint, it is passed to acceptor for initialization, so we have a constructor:

```cpp
public:
    ServerBase(unsigned short port, size_t num_threads=1) :
                endpoint(boost::asio::ip::tcp::v4(), port),
                acceptor(m_io_service, endpoint),
                num_threads(num_threads) {}
```

Until now, your code should like as follows:

```cpp
//
// server.base.hpp
//

#ifndef SERVER_BASE_HPP
#define SERVER_BASE_HPP

#include <boost/asio.hpp>

#include <regex>
#include <unordered_map>
#include <thread>

namespace LabexWeb {
    struct Request {
        std::string method, path, http_version;
        std::shared_ptr<std::istream> content;
        std::unordered_map<std::string, std::string> header;
        std::smatch path_match;
    };

    typedef std::map<std::string, std::unordered_map<std::string,
    std::function<void(std::ostream&, Request&)>>> resource_type;

    template <typename socket_type>
    class ServerBase {
    public:
        resource_type resource;
        resource_type default_resource;

        ServerBase(unsigned short port, size_t num_threads=1) :
            endpoint(boost::asio::ip::tcp::v4(), port),
            acceptor(m_io_service, endpoint),
            num_threads(num_threads) {}

        void start();
    protected:
        boost::asio::io_service m_io_service;
        boost::asio::ip::tcp::endpoint endpoint;
        boost::asio::ip::tcp::acceptor acceptor;

        size_t num_threads;
        std::vector<std::thread> threads;

        std::vector<resource_type::iterator> all_resources;

        virtual void accept() {}

        void process_request_and_respond(std::shared_ptr<socket_type> socket) const;
    };

    template<typename socket_type>
    class Server : public ServerBase<socket_type> {};
}
#endif /* SERVER_BASE_HPP */
```

```checker
- name: check file exist
  script: |
    #!/bin/bash
    ls /home/labex/Code/server.base.hpp
  error: Oops! We find that you didn't create file "server.base.hpp" in /home/labex/Code.
  timeout: 2
```

## 3. Implementation

- ServerBase
- HTTP server
- Test

### 3.1 ServerBase

There are only two methods to be implemented:

1. `void ServerBase::start()`
2. `void ServerBase::process_request_and_respond()`

First implement `start()`. When implementing `start()`, we will consider the following issues:

1. The default resource should be added to `all_resources` at the end. When we process the request path, we should handle all non-special paths first, and then use the default request resources when no matching request path is found.
2. When multiple threads are specified to be enabled, the thread needs to wait for each thread to wait until the end of the entire request reply process.

```cpp
void start() {
    // default resource in the end of vector, as response method
    for(auto it = resource.begin(); it != resource.end(); it++) {
        all_resources.push_back(it);
    }
    for(auto it = default_resource.begin(); it != default_resource.end(); it++) {
        all_resources.push_back(it);
    }

    // socket connection
    accept();

    // if num_threads>1, then m_io_service.run()
    // it will start (num_threads-1) threads as thread pool
    for(size_t c = 1;c < num_threads; c++) {
        threads.emplace_back([this](){
            m_io_service.run();
        });
    }

    // main thread
    m_io_service.run();

    // wait for other threads finish
    for(auto& t: threads)
        t.join();
}
```

Then, for `process_request_and_respond()`:

```cpp
void process_request_and_respond(std::shared_ptr<socket_type> socket) const {
    // created cache for async_read_untile()
    // shared_ptr will use for passing object to anonymous function
    // the type will be deduce as std::shared_ptr<boost::asio::streambuf>
    auto read_buffer = std::make_shared<boost::asio::streambuf>();

    boost::asio::async_read_until(*socket, *read_buffer, "\r\n\r\n",
    [this, socket, read_buffer](const boost::system::error_code& ec, size_t bytes_transferred) {
        if(!ec) {
            // Note: read_buffer->size() always equal to bytes_transferred, the document of Boost indicates:
            // after async_read_until operation, streambuf contains some extra data out of delimiter
            // thus, the best way is to read and parse the content from the left of read_buffer, then append the content of async_read
            size_t total = read_buffer->size();

            // convert istream to string-lines
            std::istream stream(read_buffer.get());

            // deduce the type of std::shared_ptr<Request>
            auto request = std::make_shared<Request>();

            // The following code need to parse request information from stream and save them to request object
            // TODO:
        }
    });
}
```

When we get the `istream` object through `read_buffer`, we need to parse this information and save it to request. To do this, we may add a `parse_request()` method:


```cpp
protected:
    Request parse_request(std::istream& stream) const {
        Request request;

        std::regex e("^([^ ]*) ([^ ]*) HTTP/([^ ]*)$");

        std::smatch sub_match;

        // read method, path and http version from the frist line
        std::string line;
        getline(stream, line);
        line.pop_back();
        if(std::regex_match(line, sub_match, e)) {
            request.method       = sub_match[1];
            request.path         = sub_match[2];
            request.http_version = sub_match[3];

            bool matched;
            e="^([^:]*): ?(.*)$";
            // parse head information
            do {
                getline(stream, line);
                line.pop_back();
                matched=std::regex_match(line, sub_match, e);
                if(matched) {
                    request.header[sub_match[1]] = sub_match[2];
                }

            } while(matched==true);
        }
        return request;
    }
```

Now, let's keep implement `process_request_and_respond()`:

```cpp
        void process_request_and_respond(std::shared_ptr<socket_type> socket) const {std::shared_ptr<boost::asio::streambuf>
            auto read_buffer = std::make_shared<boost::asio::streambuf>();
            boost::asio::async_read_until(*socket, *read_buffer, "\r\n\r\n",
            [this, socket, read_buffer](const boost::system::error_code& ec, size_t bytes_transferred) {
                if(!ec) {

                    // ...mo modification

                    // deduce the type of std::shared_ptr<Request>
                    auto request = std::make_shared<Request>();
                    *request = parse_request(stream);

                    size_t num_additional_bytes = total-bytes_transferred;

                    // if satisfy then also read
                    if(request->header.count("Content-Length")>0) {
                        boost::asio::async_read(*socket, *read_buffer,
                        boost::asio::transfer_exactly(stoull(request->header["Content-Length"]) - num_additional_bytes),
                        [this, socket, read_buffer, request](const boost::system::error_code& ec, size_t bytes_transferred) {
                            if(!ec) {
                                // pointer as istream object stored in read_buffer
                                request->content = std::shared_ptr<std::istream>(new std::istream(read_buffer.get()));
                                respond(socket, request);
                            }
                        });
                    } else {
                        respond(socket, request);
                    }
                }
            });
        }
```

Finally, at the end of the code, we need to pass the contents of the request along with the socket to `respond()` to handle the reply, so we also need to add a `respond()` method:

```cpp
protected:
    void respond(std::shared_ptr<socket_type> socket, std::shared_ptr<Request> request) const {
        // response after search requested path and method
        for(auto res_it: all_resources) {
            std::regex e(res_it->first);
            std::smatch sm_res;
            if(std::regex_match(request->path, sm_res, e)) {
                if(res_it->second.count(request->method)>0) {
                    request->path_match = move(sm_res);

                    // will be deduce to std::shared_ptr<boost::asio::streambuf>
                    auto write_buffer = std::make_shared<boost::asio::streambuf>();
                    std::ostream response(write_buffer.get());
                    res_it->second[request->method](response, *request);

                    // capture write_buffer in lambda, make sure it can be destroyed after async_write
                    boost::asio::async_write(*socket, *write_buffer,
                    [this, socket, request, write_buffer](const boost::system::error_code& ec, size_t bytes_transferred) {
                        // HTTP 1.1 connection
                        if(!ec && stof(request->http_version)>1.05)
                            process_request_and_respond(socket);
                    });
                    return;
                }
            }
        }
    }
```

```checker
- name: check content exist
  script: |
    #!/bin/bash
    grep -i 'respond' /home/labex/Code/server.base.hpp
  error: Oops! We find that you didn't implement method "respond()" in "server.base.hpp".
  timeout: 3
```

### 3.2 HTTP Server

After we complete the two important logic of header parsing and request reply, the rest is to implement different `accept()` methods for different types of servers.

In Boost, the HTTP type is an ordinary socket type (`boost::asio::ip::tcp::socket`). To do this, we can simply implement an HTTP server with less than 40 lines of code:

```cpp
//
// server.http.hpp
//

#ifndef SERVER_HTTP_HPP
#define SERVER_HTTP_HPP

#include "server.base.hpp"

namespace LabexWeb {
    typedef boost::asio::ip::tcp::socket HTTP;
    template<>
    class Server<HTTP> : public ServerBase<HTTP> {
    public:
        // use port, thread number to construct web server
        // http server is much simple than https since it doesn't need to initial config file
        Server(unsigned short port, size_t num_threads=1) :
            ServerBase<HTTP>::ServerBase(port, num_threads) {};
    private:
        // implement accept() method
        void accept() {
            // create a new socket for current connection
            // shared_ptr is used for passing temporal object to anonymous function
            // socket will be deduce as type of std::shared_ptr<HTTP>
            auto socket = std::make_shared<HTTP>(m_io_service);

            acceptor.async_accept(*socket, [this, socket](const boost::system::error_code& ec) {
                // establish a connection
                accept();
                // if no error
                if(!ec) process_request_and_respond(socket);
            });
        }
    };
}
#endif /* SERVER_HTTP_HPP */
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -i 'server<http>' /home/labex/Code/server.http.hpp
  error: Oops! We find that you didn't define class "Server<HTTP>" in "server.http.hpp".
  timeout: 3
```

### 3.3 Test

Now we can start using our framework. Your folder tree should like as follows:

```
Code
├── server.base.hpp
└── server.http.hpp
```

Our HTTP Web framework has only these two core files. Below we can develop a web server based on our web framework:

First, we create the `main` logic:

```cpp
//
// main.http.cpp
//

#include <iostream>
#include "server.http.hpp"
#include "handler.hpp"

using namespace LabexWeb;

int main() {
    // HTTP server runs in port 12345 HTTP, enable 4 threads
    Server<HTTP> server(12345, 4);
    std::cout << "Server starting at port: 12345" << std::endl;
    start_server<Server<HTTP>>(server);
    return 0;
}
```

In this logic, there is a `start_server<T>()` method that passes a `Server<HTTP>` object.
The `handler.hpp` is responsible for implementing the logic of our entire HTTP Web server instance.

In developing this processing logic, the frame resource type we mentioned earlier defines the interface we provide externally, using the following form:

```cpp
// Process a GET request to /info to return the requested information
server.resource["^/info/?$"]["GET"] = [](ostream& response, Request& request) {
     // Process requests and resources
     // ...
};
```

In order to test GET requests and POST requests, we first create a `www` directory to hold our Web resources and write some HTML code (`mkdir www`):

```html
<html>
    <head>
        <title>LabEx Web Server Test</title>
    </head>
    <body>
        Hello world in index.html.
    </body>
</html>
```

And the testing code:

```cpp
//
// handler.hpp
//

#include "server.base.hpp"
#include <fstream>

using namespace std;
using namespace LabexWeb;

template<typename SERVER_TYPE>
void start_server(SERVER_TYPE &server) {
    // resources request

    // processing POST /string, return the string from POST
    server.resource["^/string/?$"]["POST"] = [](ostream& response, Request& request) {
        // fetch string from istream (*request.content)
        stringstream ss;
        *request.content >> ss.rdbuf();     // read request to stringstream
        string content=ss.str();

        // return response
        response << "HTTP/1.1 200 OK\r\nContent-Length: " << content.length() << "\r\n\r\n" << content;
    };

    // process GET request from /info, return response
    server.resource["^/info/?$"]["GET"] = [](ostream& response, Request& request) {
        stringstream content_stream;
        content_stream << "<h1>Request:</h1>";
        content_stream << request.method << " " << request.path << " HTTP/" << request.http_version << "<br>";
        for(auto& header: request.header) {
            content_stream << header.first << ": " << header.second << "<br>";
        }

        // get the length of content_stream (use content.tellp() to get)
        content_stream.seekp(0, ios::end);

        response <<  "HTTP/1.1 200 OK\r\nContent-Length: " << content_stream.tellp() << "\r\n\r\n" << content_stream.rdbuf();
    };

    // process GET request for /match/[digit+numbers], e.g. GET request is /match/abc123, will return abc123
    server.resource["^/match/([0-9a-zA-Z]+)/?$"]["GET"] = [](ostream& response, Request& request) {
        string number=request.path_match[1];
        response << "HTTP/1.1 200 OK\r\nContent-Length: " << number.length() << "\r\n\r\n" << number;
    };

    // peocess default GET request; anonymous function will be called if no other matches
    // response files in folder web/
    // default: index.html
    server.default_resource["^/?(.*)$"]["GET"] = [](ostream& response, Request& request) {
        string filename = "www/";

        string path = request.path_match[1];

        // forbidden use `..` access content outside folder web/
        size_t last_pos = path.rfind(".");
        size_t current_pos = 0;
        size_t pos;
        while((pos=path.find('.', current_pos)) != string::npos && pos != last_pos) {
            current_pos = pos;
            path.erase(pos, 1);
            last_pos--;
        }

        filename += path;
        ifstream ifs;
        // folder inspection across platform
        if(filename.find('.') == string::npos) {
            if(filename[filename.length()-1]!='/')
                filename+='/';
            filename += "index.html";
        }
        ifs.open(filename, ifstream::in);

        if(ifs) {
            ifs.seekg(0, ios::end);
            size_t length=ifs.tellg();

            ifs.seekg(0, ios::beg);

            // copy file to response-stream , shouldn't use for large files
            response << "HTTP/1.1 200 OK\r\nContent-Length: " << length << "\r\n\r\n" << ifs.rdbuf();

            ifs.close();
        } else {
            // return unable to open if file doesn't exists
            string content="Could not open file "+filename;
            response << "HTTP/1.1 400 Bad Request\r\nContent-Length: " << content.length() << "\r\n\r\n" << content;
        }
    };

    // start HTTP(S) server
    server.start();
}
```

```checker
- name: check file exists
  script: |
    #!/bin/bash
    ls /home/labex/Code/main.http.cpp
    ls /home/labex/Code/handler.hpp
  error:  Oops! We find that you didn't create files "main.http.cpp" and "handler.hpp" in /home/labex/Code.
  timeout: 3
```

## 4. Performance Test

Until now, your folder tree should like this:

```cpp
Code
├── handler.hpp
├── main.http.cpp
├── server.base.hpp
├── server.http.hpp
└── www
    └── index.html
```

Since we use boost, the boost library is linked at compile time, but the corresponding binary is missing from the current environment, so install it manually:

```bash
$ sudo apt-get update
$ sudo apt-get install libboost-system-dev -y # provide libboost_system file
```

If you compile directly using the compile command, there will be too long instructions, we need to write a Makefile:

```makefile
#
# Makefile
#

CXX = g++
EXEC_HTTP = server.http

SOURCE_HTTP = main.http.cpp

OBJECTS_HTTP = main.http.o

LDFLAGS_COMMON = -std=c++11 -O3 -pthread -lboost_system
LDFLAGS_HTTP =

LPATH_COMMON = -I/usr/include/boost
LPATH_HTTP =

LLIB_COMMON = -L/usr/lib

all:
	make http

http:
	$(CXX) $(SOURCE_HTTP) $(LDFLAGS_COMMON) $(LDFLAGS_HTTP) $(LPATH_COMMON) $(LPATH_HTTP) $(LLIB_COMMON) $(LLIB_HTTP) -o $(EXEC_HTTP)

clean:
	rm -f $(EXEC_HTTP) *.o
```

Finally, we can use `make http` to compile our code and run our server with `./server.http` and test our server's running in the browser:

For GET requests, we can access directly in the browser:

```bash 
localhost:12345/                # access index.html
localhost:12345/match/123abc    # get a string "123abc"
localhost:12345/info/           # get the entire request body
```

For POST request, we can use `curl` command for testing:

```bash
curl -d "test string" "http://localhost:12345/string/"
```

Then you can recive the message from server, which is the string we posted to server:


![image desc](https://labex.io/upload/X/N/O/8M8gxZu0ojqu.png)


## 5. Summary

In this experiment, we implemented a `ServerBase` base class, and inherited a `Server<HTTP>` subclass for HTTP server framework. In the same time, with our framework, we implemented a HTTP Web server. While the entire process of this experiment, we uses massive C++11 and Boost Asio features. In our next experiment, we will implement a HTTPS further based on the current reuslts.`
