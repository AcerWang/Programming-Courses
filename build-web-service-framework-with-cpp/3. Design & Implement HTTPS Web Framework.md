---
show: step
version: 1.0
enable_checker: true
---

# Design & Implement HTTPS Web Framework

## 1. Introduction

Web service is the most basic unit of server side development, by abstracting the server side request and response logic, we can shape a web service framework and then achieve the highest level of frame-level code reuse. In this project, C++11 and Boost Asio will be used to implement our HTTP and HTTPS server side framework.

#### Things to Learn

- C++ Basics
- C++11 Related
- Boost Asio Related

## 2. Content

In the previous experiment, we have implemented the HTTP framework. With this framework, we can more easily reuse the framework. Boost Asio includes a class and class template for basic SSL support. This class makes it possible to implement HTTPS servers. From an implementation point of view, we only need to perform an additional layer of encryption on existing streams, such as encrypting TCP Sockets. This process is unusually simple, and we can use a little use to implement the entire HTTPS framework, as follows:

```cpp
//
// server.https.hpp
// web_server
// created by changkun at Labex.com
//

#ifndef SERVER_HTTPS_HPP
#define SERVER_HTTPS_HPP

#include "server.http.hpp"
#include <boost/asio/ssl.hpp>

namespace LabexWeb {

    // define HTTPS type
    typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> HTTPS;

    // define HTTPS service, template type is HTTPS
    template<>
    class Server<HTTPS> : public ServerBase<HTTPS> {
    public:
        // a HTTPS server requires two more parameters: certificate file and private key file
        Server(unsigned short port, size_t num_threads,
               const std::string& cert_file, const std::string& private_key_file) :
          ServerBase<HTTPS>::ServerBase(port, num_threads),
          context(boost::asio::ssl::context::sslv23) {
            // use certificate file
            context.use_certificate_chain_file(cert_file);
            // use private key file, we need pass a new parameter to specify the format
            context.use_private_key_file(private_key_file, boost::asio::ssl::context::pem);
        }

    private:
        // compare to HTTP server, we must define ssl context object
        boost::asio::ssl::context context;

        // the difference between HTTPS and HTTP server
        // is the construct difference of socket object
        // HTTPS will encrypt the IO stream socket
        // thus, accept() method must initialize ssl context
        void accept() {
            // create a new socket for current connection
            // shared_ptr is used for passing temporal object to anonymous function
            // socket will be deduce as std::shared_ptr<HTTPS>
            auto socket = std::make_shared<HTTPS>(m_io_service, context);

            acceptor.async_accept(
                (*socket).lowest_layer(),
                [this, socket](const boost::system::error_code& ec) {
                    // accept a new connection
                    accept();

                    // if no error
                    if(!ec) {
                        (*socket).async_handshake(boost::asio::ssl::stream_base::server,
                            [this, socket](const boost::system::error_code& ec) {
                            if(!ec) process_request_and_respond(socket);
                        });
                    }
            });
        }
    };
}

#endif /* SERVER_HTTPS_HPP */
```

In the entire process above, we just reimplement the `accept()` method, it pass the two files needed to enable an HTTPS server to Boost Asio, then we complete the entire server framework.

```checker
- name: check if file exist
  script: |
    #!/bin/bash
    ls /home/labex/Code/server.https.hpp
  error: Oops! We find that you didn't create file "server.https.hpp" in /home/labex/Code.
  timeout: 3
```

### 2.1 Develop HTTPS server

We have finished `handler.hpp` in the previous experiment. This file implements server resource access and processing logic. This part of the logic is essentially independent of the type of server, so we don't need to do any development at all. Simply change the server type in `main.http.cpp` to get a complete HTTPS server:

```cpp
//
// main.https.cpp
//
#include <iostream>
#include "server.https.hpp"
#include "handler.hpp"
using namespace LabexWeb;

int main() {
    // HTTPS server runs in port 12345, enable 4 threads
    // Use certificates for security
    Server<HTTPS> server(12345, 4, "server.crt", "server.key");
    std::cout << "Server starting at port: 12345" << std::endl;
    start_server<Server<HTTPS>>(server);
    return 0;
}
```

On this server, we passed in additional the required certificate and private key file for the HTTPS server.

To compile our HTTPS server, add compile options to the HTTPS server in the Makefile:

```makefile
#
# Makefile
#

CXX = g++
EXEC_HTTP = server.http
EXEC_HTTPS = server.https

SOURCE_HTTP = main.http.cpp
SOURCE_HTTPS = main.https.cpp

OBJECTS_HTTP = main.http.o
OBJECTS_HTTPS =  main.https.o

LDFLAGS_COMMON = -std=c++11 -O3 -pthread -lboost_system
LDFLAGS_HTTP =
LDFLAGS_HTTPS = -lssl -lcrypto

LPATH_COMMON = -I/usr/include/boost
LPATH_HTTP =
LPATH_HTTPS = -I/usr/include/openssl

LLIB_COMMON = -L/usr/lib

all:
	make http
	make https

http:
	$(CXX) $(SOURCE_HTTP) $(LDFLAGS_COMMON) $(LDFLAGS_HTTP) $(LPATH_COMMON) $(LPATH_HTTP) $(LLIB_COMMON) $(LLIB_HTTP) -o $(EXEC_HTTP)
https:
	$(CXX) $(SOURCE_HTTPS) $(LDFLAGS_COMMON) $(LDFLAGS_HTTPS) $(LPATH_COMMON) $(LPATH_HTTPS) $(LLIB_COMMON) $(LLIB_HTTPS) -o $(EXEC_HTTPS)

clean:
	rm -f $(EXEC_HTTP) $(EXEC_HTTPS) *.o
```

Then, our folder three becomes:

```
Code
├── Makefile
├── handler.hpp
├── main_http.cpp
├── main_https.cpp
├── server_base.hpp
├── server_http.hpp
├── server_https.hpp
└── www
    ├── index.html
    └── test.html
```

Now we can:

1. Compile the http and https servers once using `make`
2. Compile the http server separately using `make http`;
3. Compile the https server separately using `make https`.


![image desc](https://labex.io/upload/V/C/N/PQeqZD3gilR7.png)

```checker
- name: check if file exist
  script: |
    #!/bin/bash
    ls /home/labex/Code/main.https.hpp
  error: Oops! We find that you didn't create file "main.https.hpp" in /home/labex/Code.
  timeout: 3
```

### 2.2 Creat Certificates

#### Step 1: Generate Private Key

The `openssl` toolkit provides a tool for generating RSA private keys and CSR (Certificate Signing Request) files. This allows us to use it to generate a self-signed certificate for use by the HTTPS server.

The first is to generate the RSA private key. We generate a 1024-bit RSA key and use triple DES encryption and store it in PEM format (in the library we specify the format of the private key as `boost::asio::ssl::context::pem`) :

```bash
openssl genrsa -des3 -out server.key 1024
```

As shown in the figure, when generating `server.key`, we are also required to set a password. This password protects the need to provide a password when others try to access the private key (as a demonstration, let's say `123456`):


![image desc](https://labex.io/upload/W/K/R/8jopVdxikVU2.png)


As you can see, we now have the `server.key` file.

#### Step 2: Generate CSR

Now we can generate a CSR file:

```bash
openssl req -new -key server.key -out server.csr
```

In the process of generating a CSR file, you will be required to enter the protection password we just set, and you will also need to enter some relevant information, such as which domain name this certificate will be used under. Finally, you will be asked to set a challenge passwrod, which is usually not set:


![image desc](https://labex.io/upload/U/T/G/yxj0YzfkBasm.png)

#### Step 3: Remove Password from Private Key

If the certificate has a password, then it is not convenient to use a password every time the certificate is used. Moreover, the key certificate is located on our server and is not easily revealed, so we can remove the password from the key. First, we first save a copy of the key:


![image desc](https://labex.io/upload/O/E/M/ilRJiDo9r7Yx.png)

#### Step 4: Generate self-signed Certificate

Finally, generate a self-signed certificate and set the certificate's expiration time to one year:


![image desc](https://labex.io/upload/D/G/V/5n5y7eFA0i20.png)


Until now, we finally finished all necessary steps, now we can run our HTTPS server:

```
./server.https
```

Then you can visit the https server running on the `12345` port in the browser and type: `https://localhost:12345`

At this time, we will see that the browser is telling us this link is not safe:


![image desc](https://labex.io/upload/W/L/C/HC2U07lbBXK5.png)


This is due to the fact that our certificate is self-signed. Under normal circumstances, self-signed SSL certificates can be issued at will, without the audit of third-party supervision, and can not receive the trust of the browser. This is very easy to cause man-in-the-middle attacks with fake certificates, which can lead to the hijacking of SSL encrypted traffic.

When we created the certificate, we specified that this certificate will be used for the domain name `labex.io`. When we actually visit, the URL we visited is `localhost`. At this time, the browser recognizes this difference. This prevented the connection.

For testing, we can add a security exception to the list of new people added to this connection:


![image desc](https://labex.io/upload/W/O/V/4sKvkoDWIExU.png)


After the exception confirmation, we can see HTTPS resources now:


![image desc](https://labex.io/upload/W/B/S/Wa32UtprPke7.png)


Unfortuanately, we can't let the lock to be green such as company like Google:


![image desc](https://labex.io/upload/A/X/D/f5bpvf3BuJua.png)

The reason is as we mentioned before, the SSL certificate is regulated by a third party, and the certificate trusted by the browser is generally from several designated SSL certificate issuers abroad, and the issuing of such certificate often requires payment of a certain fee to the issuer. Although there are also issuers such as `Let's Encrypt` that provide free SSL certificates, you can always try them your self, that is the topic beyond this experiment.

```checker
- name: check if file exist
  script: |
    #!/bin/bash
    ls /home/labex/Code/server.crt
  error: You didn't generate "server.crt" in /home/labex/Code!
  timeout: 3
- name: check if file exist
  script: |
    #!/bin/bash
    ls /home/labex/Code/server.key
  error: You didn't generate "server.key" in /home/labex/Code!
  timeout: 3
```

## 3. Summary

After this project, we have gone through many difficult journeys. First, we developed a web framework for HTTP servers based on the features of C++11 and Boost Asio. To test our framework, we wrote our own HTTP server.

Our design was very clever. After the completion of the HTTP server Web framework and related test code, the expansion of HTTPS was developed using only a minimal amount of code. Our framework contains a total of three files:

1. server_base.hpp
2. server_http.hpp
3. server_https.hpp

Based on this framework, we have developed a simple http and https web server, and we reused the server actual logic code, placed in:

1. handler.hpp

In addition, the http and https servers we implemented based on our framework are essentially just one line of code different:

```cpp
// http server:
Server<HTTP> server(12345, 4);
// https server:
Server<HTTPS> server(12345, 4, "server.crt", "server.key");
```

We hope you enjoyed this course :)