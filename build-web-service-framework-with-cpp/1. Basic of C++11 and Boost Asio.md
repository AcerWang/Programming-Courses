---
show: step
version: 1.0
enable_checker: true
---

# Basic of C++11 and Boost Asio

## 1. Introduction

Web service is the most basic unit of server side development, by abstracting the server side request and response logic, we can shape a web service framework and then achieve the highest level of frame-level code reuse. In this project, C++11 and Boost Asio will be used to implement our HTTP and HTTPS server side framework.

#### Things to Learn

- C++ Basics
    - Object Oriented
    - Template
    - Namespace
    - Common IO Library
- C++11 Related
    - lambda expression
    - std::shared_ptr
    - std::make_shared
    - std::unordered_map
    - std::regex
    - std::smatch
    - std::regex_match
    - std::function
    - std::thread
- Boost Asio Related
    - boost::asio::io_service
    - boost::asio::ip::tcp::socket
    - boost::asio::ip::tcp::v4()
    - boost::asio::ip::tcp::endpoint
    - boost::asio::ip::tcp::acceptor
    - boost::asio::streambuf
    - boost::asio::async_read
    - boost::asio::async_read_until
    - boost::asio::async_write
    - boost::asio::transfer_exactly
    - boost::asio::ssl::stream
    - boost::asio::ssl::stream_base::server
    - boost::asio::ssl::context
    - boost::asio::ssl::context::sslv23
    - boost::asio::ssl::context::pem
    - boost::system::error_code

#### Hint

Before g++4.9, the library of regex doesn't support ECMAScript syntax, which means C++11 standard library doesn't fully support regular expression. To guarantee you can succesfully learn this project, please make sure upgrade your g++ above than 4.9.

Good news is, we already provide a complete environment for your learning, you don't have to worry about it. Moreover, this project uses `Boost` and `OpenSSL`, but we also installed for you.

## 2. C++ Basics

Object-oriented and template are the foundation of C++ advanced knowledge. We don't introduce too much here. We will develop a Web framework for this project. We will first review the knowledge of namespaces and sstream string IO streams. If you are familiar with this part, you can skip this section.

### 2.1 Namespace

When developing libraries, libraries usually have a large number of global names defined. When we use more and more libraries, it is inevitable that name conflicts will occur. This is what we often call namespace pollution.

Before the naming space was born, the usual approach was to get a function, class, or even variable name long enough to prefix each name with a corresponding prefix. For example, when we only want to define a `port` variable time:

```cpp
// oritinal name
int port;
// actual name
int labex_web_server_port;
```

The definition of the namespace is very simple. You can use the keyword `namespace` plus the name of the namespace, and then use braces to wrap the required definitions and declarations to complete the related definitions. For example:

```cpp
namespace labex_web_server {
    int port = 0;
}
```

At this moment, the `port` is confined to the namespace `labex_web_server`. If it is not specified by the namespace, it will not be accessed.

Considering:

```cpp
//
// main.cpp
//
#include <iostream>
#include "web.hpp"
#include "web2.hpp"
int main() {
    std::cout << "hello world!" << std::endl;
    std::cout << "labex_web_server, port=" << labex_web_server::port << std::endl;
    std::cout << "labex_web2_server, port=" << labex_web2_server::port << std::endl;
    return 0;
}
```

```cpp
// 
// web.hpp
//
namespace labex_web_server{
    int port = 0;
}
```

```cpp
//
// web2.hpp
//
namespace labex_web2_server{
    int port = 2;
}
```

The outputs are:

```
hello world!
labex_web_server, port=0
labex_web2_server, port=2
```

### 2.2 Common IO Methods

C++ IO library usually including `iostream`, `fstream` and `sstream`.

- iostream includes `istream`(input from stream)/`ostream`(output to stream)/`iostream`(intput and output to stream)
- fstream includes `ifstream`(intput from file)/`ofstream`(confition file output)/`fstream`(input and output file)
- sstream includes `isstringstream`(read from string)/`ostringstream`(write to string)

> In fact, there are different version regarding wide characters, we won't discuss that, you can always read the library reference.

`iostream` and `fstream` are two more commonly used IO libraries. We will not review them here. Let's briefly review `sstream`.

If you are familiar with the language C, you should know that converting int to a string type is actually a cumbersome task. Although the standard library provides the `itoa()` function, it still requires a converted C-style string ( Char *) Constructed as std::string by the constructor of std::string.
If you use stream operations, this will become unusually simple:

```cpp
#include <string>
#include <sstream>
#include <iostream>

int main() {
    // std::stringstream support read and write
    std::stringstream stream;
    std::string result;
    int number = 12345;
    stream << number;   // write number to stream
    stream >> results;  // read result from stream
    std::cout < result << std::endl; // outputs: "12345"
}
```

If we want `sstream` interact with C-style strings, we can:

```cpp
#include <sstream>
#include <iostream>

int main()
{
    std::stringstream stream;
    char result[6];
    stream << 12345;
    stream >> result;
    std::cout << result << std::endl;
}
```

One thing to note is that when performing multiple IO operations, if you want the results to have no effect on each other, you need to do a `clear()` operation on the stream object:

```cpp
stream.clear()
```

## 3. C++11 Relevant

C++11 almost redefines everything in C++. The emergence of C++11 is accompanied by a large number of useful new features and standard libraries that make C++ more modern. Even in aspects of coding paradigms. There are fundamental differences between C++11 and traditional C++. In this section we will review these features:

- lambda expression
- std::shared_ptr
- std::make_shared
- std::unordered_map
- std::regex
- std::smatch
- std::regex_match
- std::function
- std::thread

If you are familiar with these features, you can skip this section.

### 3.1 Lambda Expression

Lambda expression is one of the most important new features in C++11. Lambda expressions actually provide a feature that is similar to anonymous functions. An anonymous function requires a function, but you don't want to laboriously name it. The use of a function case continues. There are many, many scenarios like this, so anonymous functions are almost standard in modern programming languages.

The basic syntax for Lambda expression is as follows:

```
[capture_list](parameter_list) mutable(optional) exception_property -> return_type {
    // function body
}
```

The above grammar rules are well understood except the contents of `[capture_list]`, the function name is omitted and the return value is in the form of a `->`.

The so-called capture list, in fact, can be understood as a type of parameter, lambda expression internal function body by default is not able to use the function body external variables, capture list at this time can play a role in the transfer of external data. According to the transmitted behavior, the capture list is also divided into the following categories:

#### 3.1.1 Value Capture

Similar to parameter passing, the previous stage of value capture is that the variable can be copied. The difference is that the captured variable is copied when the lambda expression is created, instead of being copied when invoked:

```cpp
void learn_lambda_func_1() {
    int value_1 = 1;
    auto copy_value_1 = [value_1] {
        return value_1;
    };
    value_1 = 100;
    auto stored_value_1 = copy_value_1();
    // In this case, stored_value_1 == 1, but value_1 == 100.
    // due to copy_value_1 stored a copy when construct value_1
}
```

#### 3.1.2 Reference Capture

Similar to reference pass arguments, reference captures hold references, and values change.

```cpp
void learn_lambda_func_2() {
    int value_2 = 1;
    auto copy_value_2 = [&value_2] {
        return value_2;
    };
    value_2 = 100;
    auto stored_value_2 = copy_value_2();
    // In this case stored_value_2 == 100, value_1 == 100.
    // because of copy_value_2 stores reference
}
```

#### 3.1.3 Implicit Capture

Writing a capture list manually is sometimes very complicated. This kind of mechanical work can be handed to the compiler for processing. At this time, you can write a `&` or `=` in the capture list to declare a reference capture or value to the compiler. capture.

To summarize, capturing provides the ability to use lambda expressions for external values. The four most commonly used forms for capturing a list can be:

- [] Empty capture list
- [name1, name2, ...] capture a set of variables
- [&] Reference capture, compiler deduces capture list
- [=] Value capture, compiler deduces capture list

### 3.2 std::shared_ptr, std::make_shared

C++11 also made many improvements in memory management, one of which is `std::make_shared`. It comes with `std::shared_ptr`, which is a smart pointer that can record how many `shared_ptrs` point to a common object (which is familiar to Objective-C. This feature is called reference counting. ), can eliminate the display call `delete`, when the reference count becomes 0 will automatically delete the object.

But that's not enough, because using `std::shared_ptr` still needs to be called with `new`, which makes the code somewhat asymmetrical. Therefore, another method (factory mode) is needed to solve this problem.

`std::make_shared` can be used to eliminate the use of `new`, so `std::make_shared` assigns the object that created the passed argument and returns the `std::shared_ptr` pointer to this object type. E.g:

```cpp
#include <iostream>
#include <memory>
 
void foo(std::shared_ptr<int> i)
{
    (*i)++;
}
int main()
{
    // created a std::shared_ptr
    auto pointer = std::make_shared<int>(10);
    foo(pointer);
    std::cout << *pointer << std::endl;
}
```

### 3.3 Unordered Container std::unordered_map

In traditional C++, we already know the `std::map` associative container. When inserting an element, the `std::map` container compares the element sizes according to the `<` operator and determines whether the elements are the same or not, and selects the appropriate position for inserting to container. When elements in this container are traversed, the output will be traversed one by one in the order of the `<` operator.

C++11 finally launched an out-of-order container. One of the unordered containers is `std::unordered_map`. This container will calculate the hash value of the element and determine if the elements are the same based on the hash value. Since the unordered container does not define the order between the elements, the hash value alone is used to determine if the element already exists in the container, so when `std::unordered_map` is traversed, the result is unordered.

Let's look at an example:

```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <map>

int main() {
    // two structure initialize in same way
    std::unordered_map<int, std::string> u = {
        {1, "1"},
        {3, "3"},
        {2, "2"}
    };
    std::map<int, std::string> v = {
        {1, "1"},
        {3, "3"},
        {2, "2"}
    };
    
    // traver two structure
    std::cout << "std::unordered_map" << std::endl;
    for( const auto & n : u) 
        std::cout << "Key:[" << n.first << "] Value:[" << n.second << "]\n";
        
    std::cout << std::endl;
    std::cout << "std::map" << std::endl;
    for( const auto & n : v) 
        std::cout << "Key:[" << n.first << "] Value:[" << n.second << "]\n";
}
```

The outputs are:

```
std::unordered_map
Key:[2] Value:[2]
Key:[3] Value:[3]
Key:[1] Value:[1]

std::map
Key:[1] Value:[1]
Key:[2] Value:[2]
Key:[3] Value:[3]
```

As you can see, results from `std::map` is ordered, but `std::unordered_map` gives unordered results.

In fact, when you want accessing a single value, `std::unordered_map` will always give you better performance.

### 3.4 std::regex & std::regex_match & std::smatch

Regular expressions are another big topic that is independent of the C++ language itself, and we do not discuss its behavior in detail here.

As an introductory part of `std::regex`, we will explain some of the regular expressions we will use next:

- `[a-z]+\.txt`: In this regular expression, `[a-z]` indicates matching a lowercase letter, `+` makes the preceding expression match multiple times, so `[a-z]+` can matches a string of lowercase letters. In a regular expression, a `.` indicates that any character is matched, a `\.` indicates a matching character `.`, and a final `txt` indicates that three characters match exactly `txt`. Therefore, the matching content of this regular expression is a text file composed of pure lowercase letters.

`std::regex_match` is used to match strings and regular expressions. There are many different overloaded forms. The simplest form is to pass in `std::string` and a ``std::regex` to match. When the match is successful, it will return `true`, otherwise it will return `false`. E.g:

```cpp
#include <iostream>
#include <string>
#include <regex>

int main() {
    std::string fnames[] = {"foo.txt", "bar.txt", "test", "a0.txt", "AAA.txt"};
    // In C++, `\` will be consider as a escape character, to avoid that and makes it express as we expected in regular expression, we must escapse `\` twice for `\.`, i.e. `\\.`
    std::regex txt_regex("[a-z]+\\.txt");
    for (const auto &fname: fnames)
        std::cout << fname << ": " << std::regex_match(fname, txt_regex) << std::endl;
}
```

Another common form is to pass in three parameters `std::string`/`std::smatch`/`std::regex`, where the essence of `std::smatch` is actually `std::match_results` In the standard library, `std::smatch` is defined as `std::match_results<std::string::const_iterator>`, which is a substring iterator type `match_results`. Use `std::smatch` to easily obtain matching results, for example:

```cpp
std::regex base_regex("([a-z]+)\\.txt");
std::smatch base_match;
for(const auto &fname: fnames) {
    if (std::regex_match(fname, base_match, base_regex)) {
        // the first element of sub_match matches the entire string
        // the second element of sub_match matches the first bracket expression
        if (base_match.size() == 2) {
            std::string base = base_match[1].str();
            std::cout << "sub-match[0]: " << base_match[0].str() << std::endl;
            std::cout << fname << " sub-match[1]: " << base << std::endl;
        }
    }
}
```

The above code pieces outputs are:

```
foo.txt: 1
bar.txt: 1
test: 0
a0.txt: 0
AAA.txt: 0
sub-match[0]: foo.txt
foo.txt sub-match[1]: foo
sub-match[0]: bar.txt
bar.txt sub-match[1]: bar
```

### 3.5 std::function

`std::function` is a generic, polymorphic function wrapper whose instances can store, copy, and invoke any target entity that can be invoked. It is also a kind of existing callable entity in C++. Type-safe parcels (relatively speaking, function pointers are not typesafe). In short, `std::function` is a container of functions.

In the previous Lambda expression, we already introduced the use of the `auto` keyword to accept a lambda expression. But sometimes we may want to explicitly specify the type of this lambda expression. At this time, we can use `std::function` to write, for example:

```cpp
#include <functional>
#include <iostream>

int foo(int para) {
    return para;
}

int main() {
    // std::function wraps a function with a type of int parameter
    std::function<int(int)> func = foo;
    std::cout << func(10) << std::endl;
}
```

### 3.6 std::thread

`std::thread` is used to create an executing thread instance, so it is the basis for all concurrent programming. The headfile `<thread>` provides a lot of basic thread operations, such as `get_id()` for getting thread ID of the created thread, for example, use `join()` to join a thread, etc. For example:

```cpp
#include <iostream>
#include <thread>
void foo() {
    std::cout << "hello world" << std::endl;
}
int main() {
    std::thread t(foo);
    t.join();
    return 0;
}
```

## 4. Boost Asio Relevant

Boost is a C++ portable library that is a backup extension to the standard library and one of the development engines for the C++ standardization process. The Boost library was initiated by members of the C++ Standards Committee, and the contents of its development are likely to become part of the C++ Standard Library. So Boost is also the most influential “quasi” standard library in the C++ community.

Boost Asio is a part of the Boost library. Asio's full name is Asynchronous input and output. As the name suggests, combined with the characteristics of Boost, Asio provides a set of platform-independent asynchronous data processing capabilities (of course it also supports synchronous data processing).

In this section we will be familiar with the usage of these knowledge points, if you are more familiar with these elements, you can skip this section.

- boost::asio::io_service
- boost::asio::ip::tcp::socket
- boost::asio::ip::tcp::v4()
- boost::asio::ip::tcp::endpoint
- boost::asio::ip::tcp::acceptor
- boost::asio::streambuf
- boost::asio::async_read
- boost::asio::async_read_until
- boost::asio::async_write
- boost::asio::transfer_exactly
- boost::asio::ssl::stream
- boost::asio::ssl::stream_base::server
- boost::asio::ssl::context
- boost::asio::ssl::context::sslv23
- boost::asio::ssl::context::pem
- boost::system::error_code

To use Asio, we only need one head file:

```cpp
#include <boost/asio.hpp>
```

For all programs using Asio, at least one `io_service` object must be included. For the Asio Boost library, it abstracts concepts such as networking, serial communication, and so on, and it is unified as an IO operation, so the `io_service` class provides access to I/O. Therefore, when using Asio, you must define:

```cpp
boost::asio::io_service io;
```

### 4.1 HTTP Connection

Since the relevant concepts of the network have been abstracted as IO, we only need to care about getting messages from this IO stream. Therefore, we are essentially doing IO operations, but this operation needs to have some basic network knowledge.

We know that the underlying layers of HTTP and HTTPS are actually TCP reliable connections that are used to communicate through Socket technology, and a Socket consists of IP addresses and ports. Without exception, Asio also needs to create a socket-related object, which is `boost::asio::ip::tcp::socket`. As you can imagine, since Socket is the basis of network communication, naturally the IO operations we have to perform must be completed here. Therefore, when we want to define the `boost::asio::ip::tcp::socket` object, we must construct it by `io_service`, i.e.:

```cpp
boost::asio::ip::tcp::socket socket(io);
```

A socket object is not enough. In network communications, network IO is performed in the same manner as the ingress serial port. So this socket object can only be used as a necessary property for future IO operations.

It is easy to see that an ordinary `boost::asio::ip::tcp::socket` object is actually an HTTP Socket connection, so we can write code later and even use `typedef` This type is directly defined as `HTTP`:

```cpp
typedef boost::asio::ip::tcp::socket HTTP;
```

However, as a server, we may build many and many connections to respond to concurrency, so when we need to establish a connection, we need to use an object called `acceptor`.

The `boost::asio::ip::tcp::acceptor` can be seen from the name, this object should be used to establish a connection. In Boost, when we need to initialize an `acceptor` object, we must provide an `io_service` object and an `endpoint` object.

So what is `endpoint`? In fact, the socket is an end-to-end connection. The so-called `endpoint` is the endpoint of the server on the server. We know that the socket is composed of the IP address and port number. Then when we need to establish an IPv4 network for it, first of all, You can create a `boost::asio::ip::tcp::endpoint` object:

```cpp
unsigned short port = 8080;
boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
```

where `boost::asio::ip::tcp::v4()` is used to initialize an IPv4 network. Finally, the `endpoint` object initialize `acceptor`:

```cpp
boost::asio::ip::tcp::acceptor acceptor(io, endpoint);
```

At this point, we discussed how to use Asio to create an ordinary network operation object, `acceptor`, and a `socket` object that is needed for ordinary HTTP network operations.

### 4.2 HTTPS Connection

After discussing the HTTP connection in Asio, let's look at how HTTPS in Asio establishes a connection. Asio is an open source library, so it also inevitably needs to add dependencies on other frameworks. Asio's HTTPS-related SSL operations rely on the OpenSSL library.

To use SSL-related operations, you need to additionally introduce a header file:

```cpp
#include <boost/asio/ssl.hpp>
```

We discussed in the previous section that the Socket object generated by `boost::asio::ip::tcp::socket` is actually an ordinary HTTP object. For HTTPS, it is actually a one-level encapsulation and encryption of the channel generated by this socket. In Boost Asio, the way to encrypt a socket is to use `boost::asio::ssl::stream` and pass `boost::asio::ip::tcp::socket` as a template parameter to this object. i.e.:

```cpp
typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> HTTPS;
```

When we want to construct an HTTPS socket object, Boost Asio requires that a `boost::asio::ssl::context` object must be created for this socket. A `context` can have many different types. The most common one is `boost::asio::ssl::context::sslv23`. This is not enough after constructing the `context` object, because an https server needs to provide the certificate file and secret key file, so you have to use `use_certificate_chain_file()` and `use_private_key_file()` for further configuration:

```cpp
context.use_certificate_chain_file(cert_file);
context.use_private_key_file(private_key_file, boost::asio::ssl::context::pem);
```

where `boost::asio::ssl::context::pem` is the specified certificate type. Comparing to HTTP, the connection of HTTPS only added the steps of certificate configuration and encryption of socket:

```cpp
// http
boost::asio::ip::tcp::socket http_socket(io);
// https
boost::asio::ssl::context context(boost::asio::ssl::context::sslv23);
context.use_certificate_chain_file(cert_file);
context.use_private_key_file(private_key_file, boost::asio::ssl::context::pem);
boost::asio::ssl::stream<boost::asio::ip::tcp::socket> https_socket(io, context);
```

### 4.3 IO Operation

In above, we discussed how to establish a connection. Now let's look at how to do IO operations.

When we have a socket object, we can read network stream data from it. To read the data, we need to define a stream buffer `boost::asio::streambuf` object to read data from the socket line-by-line:

```cpp
boost::asio::streambuf read_buffer;
```

In addition, many network protocols are actually based on the implementation of the line, that is to say that these protocol elements are defined by the `\r\n` symbol, HTTP is no exception, so in Boost Asio, read the protocol using separators, You can use the `async_read_untile()` method:

```cpp
boost::asio::async_read_until(socket, readbuffer, "\r\n\r\n", read_handler);
```

where socket is our socket connection, and readbuffer is a line of data read according to the delimiter, `"\r\n\r\n"` is the delimiter, and for `read_handler` we need further discussion.

`read_handler` is a function object with no return type. It takes two arguments, one is `boost::system::error_code` and the other is `size_t`(`bytes_transferred`):

```cpp
void read_handler(
    Const boost::system::error_code& ec,
    Std::size_t bytes_transferred)
{
  ...
}
```

`boost::system::error_code` is used to describe whether the operation was successful, and `size_t bytes_transferred` is used to determine the number of bytes accepted. Normally, we can use `std::bind` to bind parameters. One of our functions is passed in, but in fact we have a better approach, that is lambda expressions, because Lambda expressions also have another function, that is, the value capture, for which we are This will be discussed in detail later when the framework is implemented.

In this `read_handler`, we are actually reading the contents of the socket constantly, so we need to use `boost::asio::async_read` for further reading of the contents of the socket, and its usage and `boost::asio::async_read_until` is almost the same, the only difference is that before the `read_handler` parameter, we need to specify the length of the read. Usually we can use `boost::asio::transfer_exactly` to specify, so this is not In detail, we will discuss in detail when we implement the framework later.

Finally, we have completed the read operation, leaving only the last step, that is, the server responds to the request and writes the request's resources to the client. At this point we need to use another method: `boost::asio:: Async_write`. As you can see from the name, this method belongs to the same family of methods as `boost::asio::async_read`. It can be imagined that the usage is completely similar. We will leave it to the actual code behind and discuss it.

## 5. Summary

In this experiment, we reviewd C++11 relavent knowledge and illstrated an introductory of Boost Asio. In the next experiment, we will use all these knowledge to implement our web service framework.

## 6. Reference

1. [C++11/14/17 Supports](http://en.cppreference.com/w/cpp/compiler_support)
2. [C++ IO Libray](http://en.cppreference.com/w/cpp/io)
3. [C++ Regular Expression](http://en.cppreference.com/w/cpp/regex)
4. [Boost Asio](http://www.boost.org/doc/libs/1_61_0/doc/html/boost_asio.html)
