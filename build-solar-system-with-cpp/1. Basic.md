---
show: step
version: 1.0
enable_checker: true
---

# Basic

## 1. Introduction

In this project, we will use OpenGL GLUT to implement a simple solar system, and learn some mathematical foundation of 3D graphics technology, coordinates of OpenGL, illumination model of OpenGL and keyboard callback event of GLUT.

#### Things to Learn

- C++ Basics
- Makefile Basics
- Object Oriented Programming
- OpenGL GLUT

#### Final Result


![image desc](https://labex.io/upload/L/V/P/knzl16pSgcHf.png)


## 2. OpenGL and GLUT

OpenGL contains a lot of rendering functions, but they are designed to be independent of any windowing system or operating system. Therefore, it does not include a function for window creating or keyboard or mouse event processing, even for the most basic display window. So using OpenGL without any other library is completely impossible to create a complete graphics program. And most programs need to interact with users (in response to keyboard, mouse and other operations). GLUT offers this convenience.

GLUT is an abbreviation of OpenGL Utility Toolkit. It is a tool library for handling OpenGL programs and it is mainly responsible for handling calls and I/O operations with the underlying operating system. The use of GLUT offers the details of the underlying operating system GUI implementation, we can only use the GLUT API to create application windows cross-platform, handle mouse and keyboard events, and more.

Let's install GLUT in our environment:

```bash
sudo apt-get install freeglut3 freeglut3-dev -y
```

A standard GLUT program looks like this:

```c++
// GLUT head file
#include <GL/glut.h>

// macro for windows
#define WINDOW_X_POS 50
#define WINDOW_Y_POS 50
#define WIDTH 700
#define HEIGHT 700

// GLUT callback
void onDisplay(void);
void onUpdate(void);
void onKeyboard(unsigned char key, int x, int y);

int main(int argc, char*  argv[]) {

    // initiate GLUT
    glutInit(&argc, argv);
    // this function specified RGBA color mode
    // and also specified single buffer or double buffer mode
    // here we use RGBA and double buffer
    glutInitDisplayMode(GLUT_RGBA |  GLUT_DOUBLE);
    // setup top left corner
    glutInitWindowPosition(WINDOW_X_POS, WINDOW_Y_POS);
    // setup height and width of window
    glutInitWindowSize(WIDTH, HEIGHT);
    // create a window, string as window title
    glutCreateWindow("SolarSystem at LabEx");

    // glutDisplayFunc(void (*func)(void))
    // accept a callback function, it calls the callback function every time when GLUT need refresh contents
    //
    // glutIdleFunc(void (*func)(void)) 
    // accept a callback function, the function will be executed everytime when GLUT feel idle
    //
    // glutKeyboardFunc(void (*func)(unsigned char key, int x, int y))
    // accept a keyboard processing callback, it passes the pressed key and position to the callback function
    //
    // the following three lines is the key of GLUT program
    glutDisplayFunc(onDisplay);
    glutIdleFunc(onUpdate);
    glutKeyboardFunc(onKeyboard);

    glutMainLoop();
    return 0;

}
```

Note that it is recommended to use GLfloat to represent floating numbers because of it brings capability for various platforms.

## 3. Class Design

In Object-oriented programming, we must figure out what are the object we shall processing. Obviously, in the entire solar systemm, objects are `Star`s, each `Star` shall has its material, and every different material decide wether has lighting property or not. Thus, we classfy planets to:

1. Star can self routate and orbit a planet
2. Planet with special material that can illuminate others.

In addition, for the convenience of programming, we must make some assumptions about the actual programming model of the real world:

1. The orbit of the planet is circular;
2. The rotation speed remains the same;
3. Assume that the time has passed for one day each time the paint is refreshed.

First of all, we can consider the following implementation logic as follows:

1. Initialize the planet object;
2. Initialize the OpenGL engine, implement `onDraw` and `onUpdate`;
3. The planet should be responsible for handling its own attributes, detouring relationships, and transforming related plots. Therefore, when designing a planet's class, it should provide a `draw()` method.
4. The planet should also handle the drawing of its updated display, such as its rotation revolution, so it should also provide an update method `update()` when designing planets.
5. The planet's `draw()` method should be called in `onDraw()`;
6. Call the planet's `update()` method in `onUpdate()`;
7. Adjust the entire solar system's display on the `onKeyboard()` keyboard.

Further, for each planet, it has the following properties:

1. Color
2. Revolution radius
3. The speed of self rotation
4. Revolution speed
5. Distance from the center of the sun
6. The detoured planet
7. The current rotation angle
8. Current rotation angle

According to the previous analysis, we can design the following classes, save it as `star.hpp` in `/home/labex/Code/`.

```c++
#ifndef star_hpp
#define star_hpp

#ifdef __APPLE__
    #include <GLUT/glut.h>
#else
    #include <GL/glut.h>
#endif

class Star {
public:
    GLfloat radius;
    GLfloat speed, selfSpeed;
    GLfloat distance;
    GLfloat rgbaColor[4];

    Star* parentStar;

    Star(GLfloat radius, GLfloat distance,
         GLfloat speed,  GLfloat selfSpeed,
         Star* parent);
    void drawStar();
    virtual void draw() { drawStar(); }
    virtual void update(long timeSpan);
protected:
    GLfloat alphaSelf, alpha;
};

class Planet : public Star {
public:
    Planet(GLfloat radius, GLfloat distance,
           GLfloat speed,  GLfloat selfSpeed,
           Star* parent, GLfloat rgbColor[3]);
    void drawPlanet();
    virtual void draw() { drawPlanet(); drawStar(); }
};

class LightPlanet : public Planet {
public:
    LightPlanet(GLfloat Radius, GLfloat Distance,
                GLfloat Speed,  GLfloat SelfSpeed,
                Star* Parent, GLfloat rgbColor[]);
    void drawLight();
    virtual void draw() { drawLight(); drawPlanet(); drawStar(); }
};

#endif /* star_hpp */
```

Furthermore, we also need to consider the design of the solar system. In the solar system, it is obviously composed of various planets; and the view of the planet after the movement of the solar system should be completed by the solar system.
According to this, the solar system member variables should contain the variables of the planet. The member function should be used to handle events such as view refresh and keyboard response in the solar system. Therefore, we can design the SolarSystem class in `solarsystem.hpp`:

```cpp
class SolarSystem {

public:

    SolarSystem();
    ~SolarSystem();

    void onDisplay();
    void onUpdate();
    void onKeyboard(unsigned char key, int x, int y);

private:
    Star *stars[STARS_NUM];

    GLdouble viewX, viewY, viewZ;
    GLdouble centerX, centerY, centerZ;
    GLdouble upX, upY, upZ;
};
```

> Note:
>
> 1. traditional array is enough to manage all planets
> 2. view definition in OpenGL is complicated, we will disscuss it later in the next experiment. For now, you only need to remember it need 9 parameters.

Finally, we also need to consider the basic parameters and variable settings.

In SolarSystem, there is a total of nine planets including the Sun (excluding Pluto), but in the Star class we designed, each Star object has Star attributes, so we can additionally implement satellites for these planets. For example, the moon that runs around the earth, according to which we consider a total of ten planets. So we can set the following enumeration for indexing an array of planets:

```cpp
#define STARS_NUM 10
enum STARS {
    Sun,
    Mercury,
    Venus,
    Earth,
    Moon,
    Mars,
    Jupiter,
    Saturn,
    Uranus,
    Neptune
};
Star * stars[STARS_NUM];
```

we also made the assumption of same self rotation speech, thus:

```cpp
#define TIMEPAST 1
#define SELFROTATE 3
```

At this point, put the unimplemented member function into the corresponding .cpp file, then we complete the experiment in this section.

```checker
- name: check file exist
  script: |
    #!/bin/bash
    ls /home/labex/Code/star.hpp
  error: Opps! We find that you didn't create file "star.hpp" in /home/labex/Code.
  timeout: 3
- name: check file exist
  script: |
    #!/bin/bash
    ls /home/labex/Code/solarsystem.hpp
  error: Opps! We find that you didn't create file "solarsystem.hpp" in /home/labex/Code.
  timeout: 3
- name: check content exist
  script: |
    #!/bin/bash
    grep -i 'star' /home/labex/Code/star.hpp
  error: Opps! We find that you didn't create class "Star" in "star.hpp".
  timeout: 3
- name: check content exist
  script: |
    #!/bin/bash
    grep -i 'planet' /home/labex/Code/star.hpp
  error: Opps! We find that you didn't create class "Planet" in "star.hpp".
  timeout: 3
- name: check content exist
  script: |
    #!/bin/bash
    grep -i 'SolarSystem' /home/labex/Code/solarsystem.hpp
  error: Opps! We find that you didn't create class "SolarSystem" in "solarsystem.hpp".
  timeout: 3
```

## 4. Summary

In this experiment, we finished `main.cpp` and created a `SolarSystem` as the key class of our solar system. Then we wrote three callback for GLUT as follows:

```cpp
//
//  main.cpp
//  solarsystem
//
#include <GL/glut.h>
#include "solarsystem.hpp"

#define WINDOW_X_POS 50
#define WINDOW_Y_POS 50
#define WIDTH 700
#define HEIGHT 700

SolarSystem solarsystem;

void onDisplay(void) {
    solarsystem.onDisplay();
}
void onUpdate(void) {
    solarsystem.onUpdate();
}
void onKeyboard(unsigned char key, int x, int y) {
    solarsystem.onKeyboard(key, x, y);
}

int main(int argc, char*  argv[]) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGBA |  GLUT_DOUBLE);
    glutInitWindowPosition(WINDOW_X_POS, WINDOW_Y_POS);
    glutCreateWindow("SolarSystem at LabEx");
    glutDisplayFunc(onDisplay);
    glutIdleFunc(onUpdate);
    glutKeyboardFunc(onKeyboard);
    glutMainLoop();
    return 0;
}
```

Moreover, we also created Star/Planet and LightPlanet class:

```cpp
//
//  star.hpp
//  solarsystem
//
//
#ifndef star_hpp
#define star_hpp

#include <GL/glut.h>

class Star {
public:
    GLfloat radius;
    GLfloat speed, selfSpeed;
    GLfloat distance;
    GLfloat rgbaColor[4];

    Star* parentStar;

    Star(GLfloat radius, GLfloat distance,
         GLfloat speed,  GLfloat selfSpeed,
         Star* parentStar);
    void drawStar();
    virtual void draw() { drawStar(); }
    virtual void update(long timeSpan);
protected:
    GLfloat alphaSelf, alpha;
};

class Planet : public Star {
public:
    Planet(GLfloat radius, GLfloat distance,
           GLfloat speed,  GLfloat selfSpeed,
           Star* parentStar, GLfloat rgbColor[3]);
    void drawPlanet();
    virtual void draw() { drawPlanet(); drawStar(); }
};

class LightPlanet : public Planet {
public:
    LightPlanet(GLfloat Radius, GLfloat Distance,
                GLfloat Speed,  GLfloat SelfSpeed,
                Star* parentStar, GLfloat rgbColor[]);
    void drawLight();
    virtual void draw() { drawLight(); drawPlanet(); drawStar(); }
};

#endif /* star_hpp */
```

In `star.hpp`, we created the template of its member function:

```cpp
//
//  star.cpp
//  solarsystem
//
#include "star.hpp"

#define PI 3.1415926535

Star::Star(GLfloat radius, GLfloat distance,
           GLfloat speed,  GLfloat selfSpeed,
           Star* parent) {
    // TODO:
}

void Star::drawStar() {
    // TODO:
}

void Star::update(long timeSpan) {
    // TODO:
}


Planet::Planet(GLfloat radius, GLfloat distance,
               GLfloat speed,  GLfloat selfSpeed,
               Star* parentStar, GLfloat rgbColor[3]) :
Star(radius, distance, speed, selfSpeed, parentStar) {
    // TODO:
}

void Planet::drawPlanet() {
    // TODO:
}

LightPlanet::LightPlanet(GLfloat radius,    GLfloat distance, GLfloat speed,
                         GLfloat selfSpeed, Star* parentStar,   GLfloat rgbColor[3]) :
Planet(radius, distance, speed, selfSpeed, parentStar, rgbColor) {
    // TODO:
}

void LightPlanet::drawLight() {
    // TODO:
}
```

Designed the class `SolarSystem`:

```cpp
//
// solarsystem.hpp
// solarsystem
//
#include <GL/glut.h>

#include "star.hpp"

#define STARS_NUM 10

class SolarSystem {

public:

    SolarSystem();
    ~SolarSystem();

    void onDisplay();
    void onUpdate();
    void onKeyboard(unsigned char key, int x, int y);

private:
    Star *stars[STARS_NUM];

    GLdouble viewX, viewY, viewZ;
    GLdouble centerX, centerY, centerZ;
    GLdouble upX, upY, upZ;
};
```

and its member functions:

```cpp
//
// solarsystem.cpp
// solarsystem
//
#include "solarsystem.hpp"

#define TIMEPAST 1
#define SELFROTATE 3

enum STARS {Sun, Mercury, Venus, Earth, Moon,
    Mars, Jupiter, Saturn, Uranus, Neptune};
    
void SolarSystem::onDisplay() {
    // TODO:
}
void SolarSystem::onUpdate() {
    // TODO:
}
void SolarSystem::onKeyboard(unsigned char key, int x, int y) {
    // TODO:
}
SolarSystem::SolarSystem() {
    // TODO:

}
SolarSystem::~SolarSystem() {
    // TODO:
}
```

`Makefile`:

```bash
CXX = g++
EXEC = solarsystem
SOURCES = main.cpp star.cpp solarsystem.cpp
OBJECTS = main.o stars.o solarsystem.o
LDFLAGS = -lglut -lGL -lGLU

all :
    $(CXX) $(SOURCES) $(LDFLAGS) -o $(EXEC)

clean:
    rm -f $(EXEC) *.gdb *.o
```

> Note:
>
> please aware the orer of -lglut -lGLU -lGL
>
> In g++, the compiler option of -l is special
>
> for example: foo1.cpp -lz foo2.cpp
>
> if foo2.cpp used library z, then the function will not be loaded.
> if foo1.o used the library z, then there will be no compiling error.
>
> In another word, the entire linking process is from left to right,
> when foo1.cpp is facing function symbol that cannot be parsed, it will
> look up the right library, then it found option z, then will look up 
> neccesary function inside z, and finish the linking.
>
> Thus, -l library must be located on the right of compiling files.
>
> More details regarding compilers, please learn g++/gdb.

Finally, we can run:

```bash
make && ./solarsystem
```

and here is the result:


![image desc](https://labex.io/upload/I/M/F/tsyDzG0oTs6x.png)


So far, the window has been created, however there is nothing to see in the window because we haven't finish the render logic of this GLUT program.

In the next experiment, we will finish the unfinished code and makes the entire solar system working correctly.

```checker
- name: check file exist
  script: |
    #!/bin/bash
    ls /home/labex/Code/star.hpp
    ls /home/labex/Code/star.cpp
    ls /home/labex/Code/solarsystem.hpp
    ls /home/labex/Code/solarsystem.cpp
    ls /home/labex/Code/main.cpp    
  error: Please make sure 'star.hpp','star.cpp','solarsystem.hpp','solarsystem.cpp','main.cpp' are created in /home/labex/Code.
  timeout: 3
```

