---
show: step
version: 1.0
enable_checker: true
---

# Implement Solar System

## 1. Introduction

In this project, we will using OpenGL GLUT to implement a simple solar system, and learning some mathematical foundation of 3D graphics technology, coordinates of OpenGL, illumination model of OpenGL and keyboard callback event of GLUT.

#### Things to Learn

- C++ Basics
- Makefile Basics
- Object Oriented Programming
- OpenGL GLUT

#### Final Result


![image desc](https://labex.io/upload/L/V/P/knzl16pSgcHf.png)

## 2. Basics

Content preview:

- Matrix in OpenGL
- Common Renderer API in OpenGL
- View Coordinates in OpenCV
- Illumination in OpenGL
  - Basic
  - Light
  - Material
  - Lighting Environment

### 2.1 Matrix in OpenGL

Perhaps you already leart matrix in your linear algebra course, however in such a course we don't know much more realistic regarding this concept. What exactly is a matrix?

Let look at an formula:

```
x = Ab
```

where `A` is a matrix, `x, b` are vectors.

**Viewpoint 1**

x and b are vectors in our 3D spaces, however `A` transforms b to x. In this case, A is a transformation.

**Viewpoint 2**

we can write `Ix = Ab`, where `I` is identity matrix. In this case, I and A are matrixes and represent coordinates for different vectors x and b, which means matrix are coordinates that represents the correlation of two vectors.
In another word, x and b are same, but its coordicate is different with each other.

Thus, the nature of matrix is *movement description*

In OpenGL, we also have a matrix responsible for rendering, which is the mode of matrix in OpenGL.

As we discussed before, matrix describes movement and coordinates, so with different operation, we need different matrix mode:

```cpp
glMatrixMode()
```

This function accept three different mode: `GL_PROJECTION`, `GL_MODElVIEW` and `GL_TEXTURE`.

- `GL_PROJECTION`: Applies subsequent matrix operations to the projection matrix stack.
- `GL_MODElVIEW`: Applies subsequent matrix operations to the modelview matrix stack.
- `GL_TEXTURE`: Applies subsequent matrix operations to the texture matrix stack.

### 2.2 Common Renderer API in OpenGL

OpenGL offers a lot of renderer API, we choose few of them for this project.

- glEnable — enable or disable server-side GL capabilities
- glPushMatrix — push and pop the current matrix stack
- glRotate — multiply the current matrix by a rotation matrix
- glTranslate — multiply the current matrix by a translation matrix
- glutSolidSphere - render a solid or wireframe sphere respectively.
- glBegin and glEnd delimit the vertices that define a primitive or a group of like primitives

The following example shows how to use glBegin and glEnd:, it renders a polygon:

```c++
glBegin(GL_POLYGON);
    for(i=0; i<n; ++i)
        glVertex2f(r*cos(2*PI/n*i), r*sin(2*PI/n*i));
glEnd();
```

### 2.3 View Coordinates in OpenCV

In our last experiment, we defined 9 parameters as member of `SolarSystem`:

```c++
GLdouble viewX, viewY, viewZ;
GLdouble centerX, centerY, centerZ;
GLdouble upX, upY, upZ;
```

In order to understand these nine variables, we first need to establish the concept of camera perspective in OpenGL three-dimensional programming.

Imagine that the scenes we watch movies at all times are actually taken from the perspective of the camera, so there are similar concepts in OpenGL. If we imagine the camera as our own head, then:

1. viewX, viewY, viewZ are equivalent to the coordinate position of the head (camera) in OpenGL world coordinates;
2. centerX, centerY, centerZ are equivalent to the coordinate position of the object seen by the head (camera shot);
3. upX, upY, upZ are equivalent to the vector of the top of the head (the top of the camera) pointing up (because we can look at an object with our head up).

At this point, we understand the concept of a coordinate system in OpenGL.

We assume that the initial perspective of this experiment is at (x, -x, x), that is:

```c++
#define REST 700
#define REST_Y (-REST)
#define REST_Z (REST)
```

The position of the observed object (the sun) is at (0,0,0), then the constructor in the `SolarSystem` class initializes the perspective to:

```c++
viewX = 0;
viewY = REST_Y;
viewZ = REST_Z;
centerX = centerY = centerZ = 0;
upX = upY = 0;
upZ = 1;
```

Now, we can establish these 9 parameters by using `gluLookAt`:

```c++
gluLookAt(viewX, viewY, viewZ, centerX, centerY, centerZ, upX, upY, upZ);
```

Then, let's take a look at `gluPerspective(GLdouble fovy,GLdouble aspect,GLdouble zNear,GLdouble zFar)`.

This function creates a symmetric, perspective view, and you need to set OpenGL's matrix mode to GL_PROJECTION before using this function. As shown as follows:


![image desc](https://labex.io/upload/H/B/W/tqZJEppJDFR8.jpg)


The screen in the window is captured by the camera. The actual captured content is the content in the far plane. The content displayed is in the near plane. Therefore, this function takes four parameters:

1. The first parameter is the size of the perspective
2. The second parameter is the aspect ratio of the actual window, as shown in the figure aspect=w/h
3. The third parameter is the near plane distance
4. The fourth parameter is the far plane distance

### 2.4 Illumination in OpenGL

#### 2.4.1 Basics

OpenGL divides the lighting system into three parts when dealing with lighting: light sources, materials, and lighting environments.

As the name suggests, light sources are sources of light, such as the sun;
Material This refers to the surface of various objects that receive light. For example, planets and moons in the solar system that are not accidental to the sun are the materials referred to here;
The lighting environment is an additional parameter. They talk about the area of the light that should be obtained. For example, the light is usually reflected multiple times. At this time, setting a parameter of “ambient brightness” can make the final picture close to the real situation.

In physics, the reflected light obtained after parallel light is incident on a smooth plane is still parallel light. This reflection is called “specular reflection”; and the reflection caused by a non-smooth plane is called “diffuse reflection”.


![image desc](https://labex.io/upload/M/A/W/0TF4bJlB0doS.jpg)


#### 2.4.2 Light

To implement the lighting system in OpenGL, the first thing we need to do is set the light source. It is worth mentioning that only a limited number of light sources (eight) are supported in OpenGL using the eight macros `GL_LIGHT0` to `GL_LIGHT7`. Enabled by the `glEnable` function, the `glDisable` function is disabled. For example: `glEnable(GL_LIGHT0);`

Setting the light source position needs to be set with `glMaterialfv`, for example:

```c++
GLfloat light_position[] = {0.0f, 0.0f, 0.0f, 1.0f};
glLightfv(GL_LIGHT0, GL_POSITION, light_position);
```

The position here is represented by four values, `(x,y,z,w)`. When `w` is 0, the light source is at infinity, and `x,y,z` specifies this infinity. The direction of the far light source; When `w` is not 0, it indicates a positional light source whose position is `(x/w, y/w, z/w)`.

#### 2.4.3 Material

To set an object's material there are generally five properties that need to be set:

1. Trace the intensity of light remaining in the environment after multiple reflections;
2. The intensity of light after diffuse reflection;
3. Illumination intensity after specular reflection;
4. Light intensity emitted by non-illuminating objects in OpenGL and not reflecting the light intensity of other objects;
5. The mirror index, the smaller the finger, the rougher the material, the light emitted by the point light source will produce a larger bright spot; on the contrary, the larger the value, the more the material looks like a mirror, resulting in a smaller bright spot.

OpenGL provides two versions of functions for materials:

```c++
void glMaterialf(GLenum face, GLenum pname, TYPE param);
void glMaterialfv(GLenum face, GLenum pname, TYPE *param);
```

The difference is that the specular index only needs to set a value, then only need to use `glMaterialf`; while other material settings need to set multiple values, this is the need to use the array to set, use the version `glMaterialfv ` with pointer vector parameters. For example:

```c++
GLfloat mat_ambient[]  = {0.0f, 0.0f, 0.5f, 1.0f};
GLfloat mat_diffuse[]  = {0.0f, 0.0f, 0.5f, 1.0f};
GLfloat mat_specular[] = {0.0f, 0.0f, 1.0f, 1.0f};
GLfloat mat_emission[] = {0.5f, 0.5f, 0.5f, 0.5f};
GLfloat mat_shininess  = 90.0f;
glMaterialfv(GL_FRONT, GL_AMBIENT,   mat_ambient);
glMaterialfv(GL_FRONT, GL_DIFFUSE,   mat_diffuse);
glMaterialfv(GL_FRONT, GL_SPECULAR,  mat_specular);
glMaterialfv(GL_FRONT, GL_EMISSION,  mat_emission);
glMaterialf (GL_FRONT, GL_SHININESS, mat_shininess);
```

#### 2.4.4 Lighting Environment

OpenGL disables illuminate environment by default, we need use `GL_LIGHTING` to enable lighting, i.e. `glEnable(GL_LIGHTING);`.

## 3. Implementation

Content preview:

- Rendering Planets
- Rendering Illuminates
- Rendering Windows
- Constructor and Destructor
- Keystroke Processing

### 3.1 Rendering Planets

When the planet is drawing, we must first consider its own revolution angle and rotation angle, so we can first implement the star class `Star::update(long timeSpan)` member function:

```c++
void Star::update(long timeSpan) {
    alpha += timeSpan * speed;
    alphaSelf += selfSpeed;
}
```

After completing the update of the revolution and rotation angles, we can draw a specific planet based on the parameters:

```cpp
void Star::drawStar() {

    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_BLEND);

    int n = 1440;

    glPushMatrix();
    {
        // Orbital revolution

        // if it is planet and distence is non-zero
        // then move a radius
        if (parentStar != 0 && parentStar->distance > 0) {
            // rotate alpha around z axis
            glRotatef(parentStar->alpha, 0, 0, 1);
            // translate distance along x axis
            glTranslatef(parentStar->distance, 0.0, 0.0);
        }
        // draw orbit
        glBegin(GL_LINES);
        for(int i=0; i<n; ++i)
            glVertex2f(distance * cos(2 * PI * i / n),
                       distance * sin(2 * PI * i / n));
        glEnd();
        // rotate alpha around z axis
        glRotatef(alpha, 0, 0, 1);
        // translate distance along x axis
        glTranslatef(distance, 0.0, 0.0);

        // self rotation
        glRotatef(alphaSelf, 0, 0, 1);

        // draw colors
        glColor3f(rgbaColor[0], rgbaColor[1], rgbaColor[2]);
        glutSolidSphere(radius, 40, 32);
    }
    glPopMatrix();

}
```

> Here we use `sin()` and `cos()`, you need `#include <cmath>`

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -i 'drawstar' /home/labex/Code/star.cpp
  error: Oops! We find that you didn't implement method "drawStar" in "star.cpp".
  timeout: 2
```

### 3.2 Rendering Illuminates

For the `Planet` class, which belongs to the non-luminous planet, we have to draw its lighting effect:

```c++
void Planet::drawPlanet() {
    GLfloat mat_ambient[]  = {0.0f, 0.0f, 0.5f, 1.0f};
    GLfloat mat_diffuse[]  = {0.0f, 0.0f, 0.5f, 1.0f};
    GLfloat mat_specular[] = {0.0f, 0.0f, 1.0f, 1.0f};
    GLfloat mat_emission[] = {rgbaColor[0], rgbaColor[1], rgbaColor[2], rgbaColor[3]};
    GLfloat mat_shininess  = 90.0f;

    glMaterialfv(GL_FRONT, GL_AMBIENT,   mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE,   mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR,  mat_specular);
    glMaterialfv(GL_FRONT, GL_EMISSION,  mat_emission);
    glMaterialf (GL_FRONT, GL_SHININESS, mat_shininess);
}
```

For the `LightPlanet` class, it is a glowing planet, so we need not only set its lighting material, but also its light position:

```c++
void LightPlanet::drawLight() {

    GLfloat light_position[] = {0.0f, 0.0f, 0.0f, 1.0f};
    GLfloat light_ambient[]  = {0.0f, 0.0f, 0.0f, 1.0f};
    GLfloat light_diffuse[]  = {1.0f, 1.0f, 1.0f, 1.0f};
    GLfloat light_specular[] = {1.0f, 1.0f, 1.0f, 1.0f};
    glLightfv(GL_LIGHT0, GL_POSITION, light_position); // specify light zero
    glLightfv(GL_LIGHT0, GL_AMBIENT,  light_ambient);  // specify abient
    glLightfv(GL_LIGHT0, GL_DIFFUSE,  light_diffuse);  // specify diffuse
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular); // specify specular

}
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -i 'drawplanet' /home/labex/Code/star.cpp
    grep -i 'drawlight' /home/labex/Code/star.cpp
  error: Oops! We find that you didn't implement method "draeplanet" and "drawlight" in "star.cpp".
  timeout: 2
```

### 3.3 Rendering Windows

In the previous experiment, we mentioned that `glutDisplayFunc` and `glutIdleFunc` are the two most important functions for image display. `glutDisplayFunc` will execute the callback function when GLUT determines that the contents of the window need updating. `glutIdleFunc` handles the callback when the event loop is idle.

In order to realize the movement of the entire solar system, we should consider when to update the position of the planet and when to refresh the view.

Obviously, `glutDisplayFunc` should focus on refreshing the view display. When the event is free, we can begin to update the position of the planet. When the location is updated, we call the view refresh function to refresh.

Therefore, we can first implement the member function `SolarSystem::onUpdate()` in the `SolarSystem` class:

```cpp
#define TIMEPAST 1
void SolarSystem::onUpdate() {

    for (int i=0; i<STARS_NUM; i++)
        stars[i]->update(TIMEPAST);

    this->onDisplay();
}
```

And then implement the viewport refresh function `SolarSystem::onDisplay()`:

```cpp
void SolarSystem::onDisplay() {

    glClear(GL_COLOR_BUFFER_BIT  |  GL_DEPTH_BUFFER_BIT);
    glClearColor(.7f, .7f, .7f, .1f);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(75.0f, 1.0f, 1.0f, 40000000);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(viewX, viewY, viewZ, centerX, centerY, centerZ, upX, upY, upZ);

    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHTING);
    glEnable(GL_DEPTH_TEST);

    // actual renderer
    for (int i=0; i<STARS_NUM; i++)
        stars[i]->draw();

    glutSwapBuffers();
}
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -i 'solarsystem::ondisplay' /home/labex/Code/solarsystem.cpp
  error: Oops! We find that you didn't implement method "onDisplay" in "solarsystem.cpp".
  timeout: 2
```

### 3.4 Constructor and Destructor

The constructor of the class defined in `star.hpp` needs to initialize the member variables in the class. It is relatively simple, and even the default destructor can be used, so we ask the you to implement these constructors:

```cpp
Star::Star(GLfloat radius, GLfloat distance,
           GLfloat speed,  GLfloat selfSpeed,
           Star* parent);
Planet::Planet(GLfloat radius, GLfloat distance,
               GLfloat speed,  GLfloat selfSpeed,
               Star* parent, GLfloat rgbColor[3]);
LightPlanet::LightPlanet(GLfloat radius, GLfloat distance,
                         GLfloat speed,  GLfloat selfSpeed,
                         Star* parent,   GLfloat rgbColor[3]);
```

> **Tip **: Note that when you initialize a speed variable it is converted to angular speed

> Its conversion formula is: alpha_speed = 360/speed

For the constructor of `SolarSystem`, we need to initialize all the planets. Here we give the appropriate parameters between the planets for convenience:

```cpp
#define SUN_RADIUS 48.74
#define MER_RADIUS  7.32
#define VEN_RADIUS 18.15
#define EAR_RADIUS 19.13
#define MOO_RADIUS  6.15
#define MAR_RADIUS 10.19
#define JUP_RADIUS 42.90
#define SAT_RADIUS 36.16
#define URA_RADIUS 25.56
#define NEP_RADIUS 24.78

#define MER_DIS    62.06
#define VEN_DIS   115.56
#define EAR_DIS   168.00
#define MOO_DIS    26.01
#define MAR_DIS   228.00
#define JUP_DIS   333.40
#define SAT_DIS   428.10
#define URA_DIS   848.00
#define NEP_DIS   949.10

#define MER_SPEED   87.0
#define VEN_SPEED  225.0
#define EAR_SPEED  365.0
#define MOO_SPEED   30.0
#define MAR_SPEED  687.0
#define JUP_SPEED 1298.4
#define SAT_SPEED 3225.6
#define URA_SPEED 3066.4
#define NEP_SPEED 6014.8

#define SELFROTATE 3

enum STARS {Sun, Mercury, Venus, Earth, Moon,
    Mars, Jupiter, Saturn, Uranus, Neptune};

// marco for planet parameters
#define SET_VALUE_3(name, value0, value1, value2) \
                   ((name)[0])=(value0), ((name)[1])=(value1), ((name)[2])=(value2)
```

> **Tips**

> We defined a `SET_VALUE_3` macro here, and readers may think that we can write a function to achieve fast setup

> In fact, the macro will complete the overall replacement work in the compilation process, and define the function

> This requires a stack operation of the function during the call. The performance is far less than the macro processing done by the compilation process.

> Therefore, using macros becomes more efficient

> But it is worth noting that while macros can become more efficient, excessive abuse can result in ugliness and poor readability of the code, while proper use of macros can be promoted.

So we can implement the constructor of the `SolarSystem` class, in which the color of the planet is randomly selected, and the reader can change the color of the planet itself:

```cpp
SolarSystem::SolarSystem() {

    // defining view
    viewX = 0;
    viewY = REST_Y;
    viewZ = REST_Z;
    centerX = centerY = centerZ = 0;
    upX = upY = 0;
    upZ = 1;

    // sun
    GLfloat rgbColor[3] = {1, 0, 0};
    stars[Sun]     = new LightPlanet(SUN_RADIUS, 0, 0, SELFROTATE, 0, rgbColor);
    // mercury
    SET_VALUE_3(rgbColor, .2, .2, .5);
    stars[Mercury] = new Planet(MER_RADIUS, MER_DIS, MER_SPEED, SELFROTATE, stars[Sun], rgbColor);
    // venus
    SET_VALUE_3(rgbColor, 1, .7, 0);
    stars[Venus]   = new Planet(VEN_RADIUS, VEN_DIS, VEN_SPEED, SELFROTATE, stars[Sun], rgbColor);
    // earth
    SET_VALUE_3(rgbColor, 0, 1, 0);
    stars[Earth]   = new Planet(EAR_RADIUS, EAR_DIS, EAR_SPEED, SELFROTATE, stars[Sun], rgbColor);
    // moon
    SET_VALUE_3(rgbColor, 1, 1, 0);
    stars[Moon]    = new Planet(MOO_RADIUS, MOO_DIS, MOO_SPEED, SELFROTATE, stars[Earth], rgbColor);
    // mars
    SET_VALUE_3(rgbColor, 1, .5, .5);
    stars[Mars]    = new Planet(MAR_RADIUS, MAR_DIS, MAR_SPEED, SELFROTATE, stars[Sun], rgbColor);
    // jupiter
    SET_VALUE_3(rgbColor, 1, 1, .5);
    stars[Jupiter] = new Planet(JUP_RADIUS, JUP_DIS, JUP_SPEED, SELFROTATE, stars[Sun], rgbColor);
    // saturn
    SET_VALUE_3(rgbColor, .5, 1, .5);
    stars[Saturn]  = new Planet(SAT_RADIUS, SAT_DIS, SAT_SPEED, SELFROTATE, stars[Sun], rgbColor);
    // uranus
    SET_VALUE_3(rgbColor, .4, .4, .4);
    stars[Uranus]  = new Planet(URA_RADIUS, URA_DIS, URA_SPEED, SELFROTATE, stars[Sun], rgbColor);
    // neptune
    SET_VALUE_3(rgbColor, .5, .5, 1);
    stars[Neptune] = new Planet(NEP_RADIUS, NEP_DIS, NEP_SPEED, SELFROTATE, stars[Sun], rgbColor);

}
```

Also, don't forget to free the requested memory in the destructor:

```c++
SolarSystem::~SolarSystem() {
    for(int i = 0; i<STARS_NUM; i++)
        delete stars[i];
}
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -i '::solorsystem' /home/labex/Code/solarsystem.cpp
  error: Oops! We find that you didn't implement the constructor "SolarSystem" in "solarsystem.cpp".
  timeout: 2
- name: check file content
  script: |
    #!/bin/bash
    grep -i '~solorsystem' /home/labex/Code/solarsystem.cpp
  error: Oops! We find that you didn't implement the destructor "~SolarSystem" in "solarsystem.cpp".
  timeout: 2
```

### 3.5 Keystroke Processing

We may use the `w, a, s, d, x` five keys on the keyboard to control the transformation of the angle of view, and use the `r` key to reset the angle of view. First, we need to determine the size of the change in the angle of view after a key press. Here we first define a macro `OFFSET`. Then use the passed `key` to determine the user's key behavior:

```c++
#define OFFSET 20
void SolarSystem::onKeyboard(unsigned char key, int x, int y) {

    switch (key)    {
        case 'w': viewY += OFFSET; break; 
        case 's': viewZ += OFFSET; break;
        case 'S': viewZ -= OFFSET; break;
        case 'a': viewX -= OFFSET; break;
        case 'd': viewX += OFFSET; break;
        case 'x': viewY -= OFFSET; break;
        case 'r':
            viewX = 0; viewY = REST_Y; viewZ = REST_Z;
            centerX = centerY = centerZ = 0;
            upX = upY = 0; upZ = 1;
            break;
        case 27: exit(0); break;
        default: break;
    }

}
```

## 4. Summary

In this experiment, we implemented `star.cpp` and `solarsystem.cpp`.

Code in `star.cpp`:

```cpp
//
//  star.cpp
//  solarsystem
//

#include "star.hpp"
#include <cmath>

#define PI 3.1415926535

Star::Star(GLfloat radius, GLfloat distance,
           GLfloat speed,  GLfloat selfSpeed,
           Star* parent) {
    this->radius = radius;
    this->selfSpeed = selfSpeed;
    this->alphaSelf = this->alpha = 0;
    this->distance = distance;

    for (int i = 0; i < 4; i++)
        this->rgbaColor[i] = 1.0f;

    this->parentStar = parent;
    if (speed > 0)
        this->speed = 360.0f / speed;
    else
        this->speed = 0.0f;
}

void Star::drawStar() {

    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_BLEND);

    int n = 1440;

    glPushMatrix();
    {
        if (parentStar != 0 && parentStar->distance > 0) {
            glRotatef(parentStar->alpha, 0, 0, 1);
            glTranslatef(parentStar->distance, 0.0, 0.0);
        }
        glBegin(GL_LINES);
        for(int i=0; i<n; ++i)
            glVertex2f(distance * cos(2 * PI * i / n),
                       distance * sin(2 * PI * i / n));
        glEnd();
        glRotatef(alpha, 0, 0, 1);
        glTranslatef(distance, 0.0, 0.0);

        glRotatef(alphaSelf, 0, 0, 1);

        glColor3f(rgbaColor[0], rgbaColor[1], rgbaColor[2]);
        glutSolidSphere(radius, 40, 32);
    }
    glPopMatrix();

}

void Star::update(long timeSpan) {
    alpha += timeSpan * speed;
    alphaSelf += selfSpeed;
}


Planet::Planet(GLfloat radius, GLfloat distance,
               GLfloat speed,  GLfloat selfSpeed,
               Star* parent, GLfloat rgbColor[3]) :
Star(radius, distance, speed, selfSpeed, parent) {
    rgbaColor[0] = rgbColor[0];
    rgbaColor[1] = rgbColor[1];
    rgbaColor[2] = rgbColor[2];
    rgbaColor[3] = 1.0f;
}

void Planet::drawPlanet() {
    GLfloat mat_ambient[]  = {0.0f, 0.0f, 0.5f, 1.0f};
    GLfloat mat_diffuse[]  = {0.0f, 0.0f, 0.5f, 1.0f};
    GLfloat mat_specular[] = {0.0f, 0.0f, 1.0f, 1.0f};
    GLfloat mat_emission[] = {rgbaColor[0], rgbaColor[1], rgbaColor[2], rgbaColor[3]};
    GLfloat mat_shininess  = 90.0f;

    glMaterialfv(GL_FRONT, GL_AMBIENT,   mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE,   mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR,  mat_specular);
    glMaterialfv(GL_FRONT, GL_EMISSION,  mat_emission);
    glMaterialf (GL_FRONT, GL_SHININESS, mat_shininess);
}

LightPlanet::LightPlanet(GLfloat radius,    GLfloat distance, GLfloat speed,
                         GLfloat selfSpeed, Star* parent,   GLfloat rgbColor[3]) :
Planet(radius, distance, speed, selfSpeed, parent, rgbColor) {
    ;
}

void LightPlanet::drawLight() {

    GLfloat light_position[] = {0.0f, 0.0f, 0.0f, 1.0f};
    GLfloat light_ambient[]  = {0.0f, 0.0f, 0.0f, 1.0f};
    GLfloat light_diffuse[]  = {1.0f, 1.0f, 1.0f, 1.0f};
    GLfloat light_specular[] = {1.0f, 1.0f, 1.0f, 1.0f};
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    glLightfv(GL_LIGHT0, GL_AMBIENT,  light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE,  light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);

}
```

Code in `solarsystem.cpp`:

```cpp
//
// solarsystem.cpp
// solarsystem
//

#include "solarsystem.hpp"

#define REST 700
#define REST_Z (REST)
#define REST_Y (-REST)

void SolarSystem::onDisplay() {

    glClear(GL_COLOR_BUFFER_BIT  |  GL_DEPTH_BUFFER_BIT);
    glClearColor(.7f, .7f, .7f, .1f);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(75.0f, 1.0f, 1.0f, 40000000);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(viewX, viewY, viewZ, centerX, centerY, centerZ, upX, upY, upZ);

    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHTING);
    glEnable(GL_DEPTH_TEST);

    for (int i=0; i<STARS_NUM; i++)
        stars[i]->draw();

    glutSwapBuffers();
}

#define TIMEPAST 1
void SolarSystem::onUpdate() {

    for (int i=0; i<STARS_NUM; i++)
        stars[i]->update(TIMEPAST);

    this->onDisplay();
}

#define OFFSET 20
void SolarSystem::onKeyboard(unsigned char key, int x, int y) {

    switch (key)    {
        case 'w': viewY += OFFSET; break;
        case 's': viewZ += OFFSET; break;
        case 'S': viewZ -= OFFSET; break;
        case 'a': viewX -= OFFSET; break;
        case 'd': viewX += OFFSET; break;
        case 'x': viewY -= OFFSET; break;
        case 'r':
            viewX = 0; viewY = REST_Y; viewZ = REST_Z;
            centerX = centerY = centerZ = 0;
            upX = upY = 0; upZ = 1;
            break;
        case 27: exit(0); break;
        default: break;
    }

}

#define SUN_RADIUS 48.74
#define MER_RADIUS  7.32
#define VEN_RADIUS 18.15
#define EAR_RADIUS 19.13
#define MOO_RADIUS  6.15
#define MAR_RADIUS 10.19
#define JUP_RADIUS 42.90
#define SAT_RADIUS 36.16
#define URA_RADIUS 25.56
#define NEP_RADIUS 24.78

#define MER_DIS   62.06
#define VEN_DIS  115.56
#define EAR_DIS  168.00
#define MOO_DIS   26.01
#define MAR_DIS  228.00
#define JUP_DIS  333.40
#define SAT_DIS  428.10
#define URA_DIS 848.00
#define NEP_DIS 949.10

#define MER_SPEED   87.0
#define VEN_SPEED  225.0
#define EAR_SPEED  365.0
#define MOO_SPEED   30.0
#define MAR_SPEED  687.0
#define JUP_SPEED 1298.4
#define SAT_SPEED 3225.6
#define URA_SPEED 3066.4
#define NEP_SPEED 6014.8

#define SELFROTATE 3

enum STARS {Sun, Mercury, Venus, Earth, Moon,
    Mars, Jupiter, Saturn, Uranus, Neptune};

#define SET_VALUE_3(name, value0, value1, value2) \
                   ((name)[0])=(value0), ((name)[1])=(value1), ((name)[2])=(value2)

SolarSystem::SolarSystem() {

    viewX = 0;
    viewY = REST_Y;
    viewZ = REST_Z;
    centerX = centerY = centerZ = 0;
    upX = upY = 0;
    upZ = 1;

    GLfloat rgbColor[3] = {1, 0, 0};
    stars[Sun]     = new LightPlanet(SUN_RADIUS, 0, 0, SELFROTATE, 0, rgbColor);

    SET_VALUE_3(rgbColor, .2, .2, .5);
    stars[Mercury] = new Planet(MER_RADIUS, MER_DIS, MER_SPEED, SELFROTATE, stars[Sun], rgbColor);

    SET_VALUE_3(rgbColor, 1, .7, 0);
    stars[Venus]   = new Planet(VEN_RADIUS, VEN_DIS, VEN_SPEED, SELFROTATE, stars[Sun], rgbColor);

    SET_VALUE_3(rgbColor, 0, 1, 0);
    stars[Earth]   = new Planet(EAR_RADIUS, EAR_DIS, EAR_SPEED, SELFROTATE, stars[Sun], rgbColor);

    SET_VALUE_3(rgbColor, 1, 1, 0);
    stars[Moon]    = new Planet(MOO_RADIUS, MOO_DIS, MOO_SPEED, SELFROTATE, stars[Earth], rgbColor);

    SET_VALUE_3(rgbColor, 1, .5, .5);
    stars[Mars]    = new Planet(MAR_RADIUS, MAR_DIS, MAR_SPEED, SELFROTATE, stars[Sun], rgbColor);

    SET_VALUE_3(rgbColor, 1, 1, .5);
    stars[Jupiter] = new Planet(JUP_RADIUS, JUP_DIS, JUP_SPEED, SELFROTATE, stars[Sun], rgbColor);

    SET_VALUE_3(rgbColor, .5, 1, .5);
    stars[Saturn]  = new Planet(SAT_RADIUS, SAT_DIS, SAT_SPEED, SELFROTATE, stars[Sun], rgbColor);

    SET_VALUE_3(rgbColor, .4, .4, .4);
    stars[Uranus]  = new Planet(URA_RADIUS, URA_DIS, URA_SPEED, SELFROTATE, stars[Sun], rgbColor);

    SET_VALUE_3(rgbColor, .5, .5, 1);
    stars[Neptune] = new Planet(NEP_RADIUS, NEP_DIS, NEP_SPEED, SELFROTATE, stars[Sun], rgbColor);

}
SolarSystem::~SolarSystem() {
    for(int i = 0; i<STARS_NUM; i++)
        delete stars[i];
}
```

We can run the program in terminal:

```bash
make && ./solarsystem
```

Our final result is as follows:


![image desc](https://labex.io/upload/L/V/P/knzl16pSgcHf.png)


We can also adjust the view angle of this program by keystroke:

![image desc](https://labex.io/upload/C/D/S/S0Z0ZPkDxSLD.png)



## 5. Reference

1. D Shreiner, OpenGL Programming Guide, 2005
