---
show: step
version: 1.0
enable_checker: true
---
# Environment Variable and Find Files


## 1. Introduction

#### 1.1 Content

This section introduces the role and usage of environment variables, as well as several ways to search for documents. After learning these techniques, you're one step closer to a Linux master.

#### 1.2 Key Points

- Environment Variable
- `$PATH`
- locate, which, find command


## 2. Environment Variable
- Environment Variable
- Find the path and order for a command
- Add a path to the PATH environment variable
- Modify and delete existing variables
- How to make the environment variables take effect immediately

### 2.1 Variable

In order for us to effectively deliver an explanation on environment variable, you must first understand what a variables is. A variable is a symbol used in a computer to record a value (not just a value, it can also be a character or a string), and these symbols are used in different operations. Usually a variable and a value are in an exclusive one-to-one relationship. You can read a value using expression and assign it to other variables. You can also specify the value assigned to any variable. For operation and processing, most of the programming languages will distinguish the type of variable respectively for the value, character and string. Shell variables are basically the same as programming language. Variables have different types and scopes. What's more, they can even participate in operations.

How to create a variable in the Shell and how to read the value of that variable

Use the command `declare` to create a variable named tmp

```
$ declare tmp
```

 In fact, you don't need to declare a variable at first, you can create it when you want to use it.

Use `=` to assign the variable `tmp` to `labex`

```
$ tmp=labex
```

Use `echo` and `$` to read the value of a variable（`$` is used to refer to the value of a variable, don't forget to enter）

```
$ echo $tmp
```


![image desc](https://labex.io/upload/I/O/R/1A47x5oonVgH.png)


Not any form of variable names are available. variable names can only contain letters, numbers and underlines. In addition, names starting with a number are not available.

### 2.2 Environment variable

The scope of an environment variable is larger than a custom variable. For example, the shell's environment variable can exert an effect on itself and its child process. In all UNIX and UNIX-like systems, each process has its own environment variable settings. By default, when a process is created, it inherits most of the environment settings of its parent process. Shell programs also run as a process on top of the operating system, and most of the commands we run in the shell will run as shell's child process.

We will use three variable types

- Private custom variables of current shell process, such as`tmp` we've created above which is only valid in the current Shell.
- Buily-in variable of Shell.
- Environment variables derived from custom variables.

There are three commands related to the above three environment variables `set`, `env`, `export`. These three commands are very similar. They are used to print environment variable information. The range of variables involved varies though. 

 Command   Description  

 `set`     It can display all variables of the current shell, including its built-in environment variables, user-defined variables, and exported environment variables. 

 `env`     It can display the environment variables associated with the current user, and allow the command to run in the specified environment. 
 `export`  It displays variables that are exported from the shell as environment variables, and it can also export custom variables as environment variables. 

```
$ temp=labex
$ export temp_env=labex
$ envsortenv.txt
$ exportsortexport.txt
$ setsortset.txt
```

In the above commands, the output of the command is sorted through `` using the command `sort`, and finally redirected the output to the object file.

You can use `vimdiff` to compare the differences between them


```
$ vimdiff env.txt export.txt set.txt
```

The variable which is valid for the child process of the current process is the environment variable, otherwise it is not. We use `export` to experiment. First, we set a variable `temp = labex` in the shell . And then we create a sub-shell to see variable value  `temp`



In order to distinguish between ordinary variables, oftentimes we name the environment variable with uppercase letters.


#### How to keep the environment variables permanent

When you shut down, or close the current shell, the environment variable is gone. How can we keep the environment variables permanently

According to the variable life cycle, Linux variables can be divided into two categories

1. Permanent variable：you need to modify the configuration file, then the variable will take effect permanently;

2. Temporary variables：use only the `export` command. The variable is invalid when the shell is closed.

Linux has two important files `etcbashrc` and `etcprofile`. They store shell variables and environment variables. Note that there is a hidden file in each user directory

```
.profile you can use ls -a to view this file
cd homelabex
ls -a 
```

`.profile` only valid for the current user. Environment variables written in `etcprofile` are valid for all users. So if you want to add a valid environment variable, just open the `etcprofile` and add the environment variable at the end of the file.


### 2.3 Find the path and order for a command

You may have a question about when we enter a command in the Shell, how does Shell know where to find this command This is done by the environment variable `PATH`. `PATH` saves the search paths of commands.

View the contents of the `PATH` environment variable

```
$ echo $PATH
```

By default, you will see the following output

```
/opt/swift/usr/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/labex/anaconda3/bin
```

Next we will practice creating the simplest executable shell script and a hello world program using C language. If you have not learnt that, then you need to complete an introductory course first
[Linux Shell Scripting Tutorial (LSST) v2.0](httpbash.cyberciti.bizguideMain_Page) 。

Create a Shell script file

```
$ gedit hello_shell.sh
```

Add the following in the script, then save and exit（Do not omit the first line）：

```
#! /bin/bash

for ((i=0; i<10; i++));do
    echo "hello shell"
done

exit 0
```

Add the executable permission to this script

```
$ chmod 755 hello_shell.sh
```

Run the script

```
$ .hello_shell.sh
```

Create a hello world program

```
$ gedit hello_world.c
```

```
#include <stdio.h>

int main(void)
{
    printf("hello world!\n");
    return 0;
}
```
Save and use `gcc` to generate the executable file

```
$ gcc hello_world.c -o hello_world
```

 The binary file that gcc generated has the executable permission

Create a directory named `mybin` in the `labex` directory. And move the `hello_shell.sh` and `hello_world` to it

```
$ mkdir mybin
$ mv hello_shell.sh hello_world mybin
```

Now you can run the two programs you just created in `mybin`

```
$ cd mybin
$ .hello_shell.sh
$ .hello_world
```


Then we go back to `labex` directory. When you want to run the two programs using the above commands, the terminal will display command cannot find. You need to add the full path to the programs, but it is very inconvenient. How to do the same as using the system command to execute our own programs We can do it through adding the path to the `PATH` environment variable.

### 2.4 Add a path to the PATH environment variable

`is a delimiter in `PATH`. We can add a path like this

```
$PATH=$PATH%"homeshiyanloumybin"
```

Be sure to use an absolute path

Now you can execute the two commands in any directory (you need to remove `.`). It is not a good solution to the problem, because I added a path to the `PATH` environment variable. It only works in the current shell. Once I quit the terminal, the previous settings for `PATH` will be invalid. Is there a way that each time when you start a Shell, the system will automatically add the path to `PATH`

In each user's home directory, there is a configuration script that will run automatically to initialize the environment, including adding some environment variables and so on. zsh configuration file is `.zshrc`. And Bash configuration file is `.Bashrc`. They also have one or more global configuration files under etc, but usually we only modify the configuration file in user directory.

We can use the following command to add content  to `.zshrc`

```
$ echo PATH=$PATHhomelabexmybin  .zshrc
```

In the above command, `` indicates that the standard output is redirected to a file. A new file will be created if the specified file does not exist


### 2.5 Modify and delete existing variables

#### Variable modification

Variables can be modified in the following ways

 Setting method                    Description                              
--------------------------------  ----------------------------------------
 `${name#match string}`            From front to back, delete the shortest string that matches the string 
 `${name##match string}`           From front to back, delete the longest string that matches the string 
 `${name%match string}`            From back to front, delete the shortest string that matches the string 
 `${name%%match string}`           From back to front, delete the longest string that matches the string 
 `${nameold stringnew string}`   Replace the first string that matches the old string with the new string 
 `${nameold stringnew string}`  Replace all strings that match the old string with the new string 

Modify the path as follows

```
$ path=$PATH
$ echo $path
$ path=${path%homeshiyanloumybin}
$ path=${path%mybin}
```


#### Delete an environment variable

You can use `unset` to delete an environment variable

```
$ unset temp
```

### 2.6 How to make the environment variables take effect immediately

When we modify the configuration script, we have to re-open the terminal or even restart the host before it takes effect. It is very troublesome, but we can use `source` to let it work immediately, such as

```
$ source .zshrc
```

 `.` is an alias for `source`. So you can use it like this

```
$ . ..zshrc
```

When you use `.`, the following file must specify the full absolute or relative path name, but `source` is not required.

## 3、Search for files

- `whereis`

```
$whereis who
```


You use this command to find three paths. Two of them are the paths of executable files and another one is the path of a `man` online help file. This search is really quick because it does not look up from the hard disk; instead it queries directly from the database. `whereis` can only search for binary files (-b), man help files (-m), and source code files (-s). If you want to get more comprehensive search results you can use the `locate` command.

- `locate`

This command finds files through the varlibmlocatemlocate.db database, but this database is not updated in real time. The system will automatically update once a day. So it may not find the file that you just added. You need to manually update using the `updatedb` command. `locate` can be used to find different file types, such as finding all files that start with sh

```
$ locate etcsh
```

 Note that it is not only in the `etc` directory to find files, but also automatically recursive subdirectory to find.

Find all jpg files under `usrshare`

```
$ locate usrshare.jpg
```

You can add the `-c` parameter to count the number of files. Adding` -i` parameter can search ignoring cases. The parameters `-b`, `-m`, `-s` of `whereis` can also be used.

- `which`

`which` is a shell built-in command. We usually use `which` to determine whether to install a software, because it only searches from the `PATH` environment variable to search a command

```
$ which man
```

- `find`

`Find` should be the most powerful of these commands. It can not only find files by file type, file name, but can also search files based on file attributes (such as file timestamp, file permissions, and etc.).
The following command can search for a file or directory named interfaces in the `etc` directory. This is the most common form of `find`. Remember the first parameter of find is the search destination

```
$ sudo find etc -name interfaces
```

Time-related parameters

 Parameter  Description 

 `-atime`   Last visit time                          

 `-ctime`   The last time to modify the contents of the file 
 `-mtime`   The last time to modify the file attributes 

Take `-mtime` for example：

- `-mtime n`：The file that was modified in the day before n days
- `-mtime +n`：List the files that were modified before n days (not including the n day)
- `-mtime -n`：List the files that have been modified within n days (including the day)
- `-newer file`：file is an existing file. List all files that are more recent than the file


List all files that have changed within 24 hours

```
$ find ~ -mtime 0
```

List all files that are more recent than the Code folder in the user directory

```
$ find ~ -newer homeshiyanlouCode
```


## 4. Addition

### Time for Fun

Many people are amazed by the special effects in The Matrix. In Linux, you can easily achieve this effect using `cmatrix`.

You need to install this command, because Ubuntu does not have it pre-installed.

```
$ sudo apt-get update
$ sudo apt-get install cmatrix
$ cmatrix
```

Do not execute the command immediately. In order to see the effects in a better view, first we need to change the theme of the terminal color to black and green. Modification method as shown below


![image desc](https://labex.io/upload/N/R/A/iZyT5qixuScH.png)


## 5. Homework

###  Find the files

Find all files with suffixes `.conf` in `etc`.