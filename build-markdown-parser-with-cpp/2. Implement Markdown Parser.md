---
show: step
version: 1.0
enable_checker: true
---

# Implement Markdown Parser

## 1. Introduction

Markdown has became the standard way of writing documentation within programmer community. Its succinct syntax can help us to understanding the lexical analysis of compiler. In this project, we will implement a Markdown parser by using C++, and generate the content into HTML eventually.

#### Things to Learn

- lexical analysis
- syntax tree
- DFS: Deep First Search
- C++11
- C pointer for char stream processing

#### Final Results

The following figure illustrates the final output of our markdown parser:

![image desc](https://labex.io/upload/J/Q/V/D3yhhIZBEL4x.png)

Our final project folder will be as follows:

```
MarkdownParser
├── main.cpp
├── mdtransform.hpp
├── output
│   └── github-markdown.css
└── test.md
```

#### Review

In our last experiment, we finished the designing of the class, determinate the lexical token. In this experiment we tend to finish all of them.

## 2. Work Flow

**Parser Workflow**

In our last experiment, we has defined `getTableOfContents()` and `getContents()` methods for getting HTML from variable `TOC` and `content`. Thus, The entire markdown parser flow should based on constructor.

Usually, constructor provides the parameter for parsing file, which means we need processing and reading character from file streaming.

Before our implementation, let's consider how to store our parsed contents.

**Basic Structure**

First of all, we clarify that markdown and html are similar, then share same DOM three structure, which means we have to implement a tree structure as well:

```C++
// 
// mdtransform.hpp
//
// save table of contents
typedef struct Cnode {
    vector <Cnode *> ch;
    string heading;
    string tag;
    Cnode (const string &hd): heading(hd) {}
} Cnode;

// save contents
typedef struct node {
    int type;                           // doc type of the node
    vector <node *> ch;
    string elem[3];                     // store properties elem[0] saves content
                                        // elem[1] saves links, elem[2] saves title
    node (int _type): type(_type) {}
} node;
```

To make sure parsing works, we need `MarkdownTransform` class to own the following properties:

```cpp
private:
    node  *root, *now;
    Cnode *Croot;
```

In the meanwhile, we also need a `cntTag` variable for recording the parsing position of HTML in `MarkdownTransform` class:

```cpp
int cntTag = 0;
```

and a cache array for saving the processing line:

```cpp
char s[maxLength]
```

where `#define maxLength 10000`.

```checker
- name: check if file exist
  script: |
    #!/bin/bash
    ls /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't create file "mdtransform.hpp" in /home/labex/Code!
  timeout: 3
- name: check file content
  script: |
    #!/bin/bash
    grep -i 'node' /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't define struct "node" and "Cnode" in "mdtransform.hpp"!
  timeout: 2
```

## 3. Implementation

Content preview:

- Process Spaces and Tabs
- Determine Line Type
- Type Retrieve
- Node Search
- Insert New Node
- Process New Line and Paragraph
- Iterate and Generate
- Core Logic of Construction
- Core Logic of Desctruction

### 3.1 Process Spaces and Tabs

Space doesn't influence our markdown parser, the only way of ignore them is to processing space and tab simultaneously.

```cpp
// Parse spaces and tabs in the begining of a line
inline pair<int, char *> start(char *src) {
    // immediately return if empty
    if ((int)strlen(src) == 0)
        return make_pair(0, nullptr);
    // counting spaces and tabs
    int cntspace = 0, cnttab = 0;
    // read from the first char, couting spaces and tabs
    // stop if the chart is not space and tab anymore
    for (int i = 0; src[i] != '\0'; i++) {
        if (src[i] == ' ') cntspace++;
        else if (src[i] == '\t') cnttab++;
        // only counting tabs if spaces and tabs mixed
        // 1 tab == 4 space
        return make_pair(cnttab + cntspace / 4, src + i);
    }
    return make_pair(0, nullptr);
}
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -i '\t' /home/labex/Code/mdtransform.hpp
    grep -i "' '" /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't parse space ' ' and  tab '\t' in "mdtranform.hpp"!
  timeout: 2
```

### 3.2 Determine Line Type

The reason of parsing markdown becomes simple is the syntax of markdown makes most of its syntax rely on the first char of each line, such as `#` and `-`.

```cpp
// Judge the type a current line
inline pair<int, char *> JudgeType(char *src) {
    char *ptr = src;

    // jump `#`
    while (*ptr == '#') ptr++;

    // <h> tag if has space immediately
    if (ptr - src > 0 && *ptr == ' ')
        return make_pair(ptr - src + h1 - 1, ptr + 1);

    // reset analysis position
    ptr = src;

    // code block syntax if ``` appears
    if (strncmp(ptr, "```", 3) == 0)
        return make_pair(blockcode, ptr + 3);

    // list syntax if * + - appears and next char is space
    if (strncmp(ptr, "- ", 2) == 0)
        return make_pair(ul, ptr + 1);

    // quote syntax if > appears and next char is space
    if (*ptr == '>' && (ptr[1] == ' '))
        return make_pair(quote, ptr + 1);

    // ordered list syntax if number and next char is `.` appears
    char *ptr1 = ptr;
    while (*ptr1 && (isdigit(*ptr1))) ptr1++;
    if (ptr1 != ptr && *ptr1 == '.' && ptr1[1] == ' ')
        return make_pair(ol, ptr1 + 1);

    // otherwise it is a normal paragraph
    return make_pair(paragraph, ptr);
}
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -E '#|.|-|>|```' /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't judge line type: "#", ". ", "- ", "> ", "```" !
  timeout: 2
```

### 3.3 Type Retrieve & Node Search

**Type retrieve**

```cpp
inline bool isHeading(node *v) {
    return (v->type >= h1 && v->type <= h6);
}
inline bool isImage(node *v) {
    return (v->type == image);
}
inline bool isHref(node *v) {
    return (v->type == href);
}
```

**Node search**

When we construct a new syntax structure with syntax tree, it is neccesary to search the node of tree for parsing task. Thus:

```cpp
// deep search for a tree
// depth: depth of a tree
// return: node pointer
inline node* findnode(int depth) {
    node *ptr = root;
    while (!ptr->ch.empty() && depth != 0) {
        ptr = ptr->ch.back();
        if (ptr->type == li)
            depth--;
    }
    return ptr;
}
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -iE 'head|image|href' /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't define function "isHeading()/isImage()/isHref()" to determine if a node is head/image/href in "mdtransform.hpp" !
  timeout: 2
  - name: check file content
  script: |
    #!/bin/bash
    grep -i 'findnode' /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't define function "findnode()" in "mdtransform.hpp" !
  timeout: 2
```

### 3.4 Insert New Node

Node insertion is divided into two types, one is to insert a TOC into the tree of Cnode structure, and the other is to insert the parsed content into the tree of `node` structure. When these structures are inserted, in order to jump to the body correctly The corresponding content, we set the `tag` to mark the contents of this directory

```cpp
void Cins(Cnode *v, int x, const string &hd, int tag) {
    int n = (int)v->ch.size();
    if (x == 1) {
        v->ch.push_back(new Cnode(hd));
        v->ch.back()->tag = "tag" + to_string(tag);
        return ;
    }

    if (!n || v->ch.back()->heading.empty())
        v->ch.push_back(new Cnode(""));
    Cins(v->ch.back(), x - 1, hd, tag);
}
```

And for the body part, the most difficult task is to deal with the figure and hyperlink in a paragraph. This means that we need to judge and handle characters one by one. This is the reason why we use C-style strings and char pointers when dealing with parsing code, rather than simply using `std :: string`.

```cpp
// insert string to specific node
// v: node
// src: source string
void insert(node *v, const string &src) {
    int n = (int)src.size();
    bool incode = false,
            inem = false,
            instrong = false,
            inautolink = false;
    v->ch.push_back(new node(nul));

    for (int i = 0; i < n; i++) {
        char ch = src[i];
        if (ch == '\\') {
            ch = src[++i];
            v->ch.back()->elem[0] += string(1, ch);
            continue;
        }

        // processing inline code
        if (ch == '`' && !inautolink) {
            incode ? v->ch.push_back(new node(nul)) : v->ch.push_back(new node(code));
            incode = !incode;
            continue;
        }

        // processing bold font
        if (ch == '*' && (i < n - 1 && (src[i + 1] == '*')) && !incode && !inautolink) {
            ++i;
            instrong ? v->ch.push_back(new node(nul)) : v->ch.push_back(new node(strong));
            instrong = !instrong;
            continue;
        }
        if (ch == '_' && !incode && !instrong && !inautolink) {
            inem ? v->ch.push_back(new node(nul)) : v->ch.push_back(new node(em));
            inem = !inem;
            continue;
        }

        // processing figure
        if (ch == '!' && (i < n - 1 && src[i + 1] == '[')
            && !incode && !instrong && !inem && !inautolink) {
            v->ch.push_back(new node(image));
            for (i += 2; i < n - 1 && src[i] != ']'; i++)
                v->ch.back()->elem[0] += string(1, src[i]);
            i++;
            for (i++; i < n - 1 && src[i] != ' ' && src[i] != ')'; i++)
                v->ch.back()->elem[1] += string(1, src[i]);
            if (src[i] != ')')
                for (i++; i < n - 1 && src[i] != ')'; i++)
                    if (src[i] != '"')
                        v->ch.back()->elem[2] += string(1, src[i]);
            v->ch.push_back(new node(nul));
            continue;
        }

        // processing hyper link
        if (ch == '[' && !incode && !instrong && !inem && !inautolink) {
            v->ch.push_back(new node(href));
            for (i++; i < n - 1 && src[i] != ']'; i++)
                v->ch.back()->elem[0] += string(1, src[i]);
            i++;
            for (i++; i < n - 1 && src[i] != ' ' && src[i] != ')'; i++)
                v->ch.back()->elem[1] += string(1, src[i]);
            if (src[i] != ')')
                for (i++; i < n - 1 && src[i] != ')'; i++)
                    if (src[i] != '"')
                        v->ch.back()->elem[2] += string(1, src[i]);
            v->ch.push_back(new node(nul));
            continue;
        }

        v->ch.back()->elem[0] += string(1, ch);
        if (inautolink) v->ch.back()->elem[1] += string(1, ch);
    }
    if (src.size() >= 2)
        if (src.at(src.size() - 1) == ' ' && src.at(src.size() - 2) == ' ')
            v->ch.push_back(new node(br));
}
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -i 'insert' /home/labex/Code/mdtransform.hpp | grep -i 'node'
  error: Oops! We find that you didn't define function "insert()" to insert a node in "mdtransform.hpp" !
  timeout: 2
```

### 3.5 Process New Line and Paragraph

It is important whether to create a new line or not in markdown. Because mardkwon supports artificial segmentation by using `---`, and at the same time it does not break the code's properties, so it's important if a line needs to be wrapped in HTML:

```cpp
// check if need a new line
inline bool isCutline(char *src) {
    int cnt = 0;
    char *ptr = src;
    while (*ptr) {
        // no need for newline if not space, tab, - or *
        if (*ptr != ' ' && *ptr != '\t' && *ptr != '-')
            return false;
        if (*ptr == '-')
            cnt++;
        ptr++;
    }
    // need a new line if --- appears
    return (cnt >= 3);
}
```

In most case, we will have a paragraph, thus:

```cpp
// generate paragraph
inline void mkpara(node *v) {
    if (v->ch.size() == 1u && v->ch.back()->type == paragraph)
        return;
    if (v->type == paragraph)
        return ;
    if (v->type == nul) {
        v->type = paragraph;
        return ;
    }
    node *x = new node(paragraph);
    x->ch = v->ch;
    v->ch.clear();
    v->ch.push_back(x);
}
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -i 'line(char' /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't define function "isCutline()" in "mdtransform.hpp" !
  timeout: 2
  - name: check file content
  script: |
    #!/bin/bash
    grep -i 'para' /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't define function "mkpara()" to generate paragraph in "mdtransform.hpp" !
  timeout: 2
```

### 3.6 Iterate and Generate

Interating syntax tree need to be deep first, however, it is different for the table of content because of the output behavior, thus we need implement in different way:

```cpp
void dfs(node *v) {
    if (v->type == paragraph && v->elem[0].empty() && v->ch.empty())
        return ;

    content += frontTag[v->type];
    bool flag = true;

    // processing headings, support TOC jump
    if (isHeading(v)) {
        content += "id=\"" + v->elem[0] + "\">";
        flag = false;
    }

    // processing hyper links
    if (isHref(v)) {
        content += "<a href=\"" + v->elem[1] + "\" title=\"" + v->elem[2] + "\">" + v->elem[0] + "</a>";
        flag = false;
    }

    // processing figures
    if (isImage(v)) {
        content += "<img alt=\"" + v->elem[0] + "\" src=\"" + v->elem[1] + "\" title=\"" + v->elem[2] + "\" />";
        flag = false;
    }

    // otherwise push contents
    if (flag) {
        content += v->elem[0];
        flag = false;
    }

    // iterate all
    for (int i = 0; i < (int)v->ch.size(); i++)
        dfs(v->ch[i]);

    // add suffix tag
    content += backTag[v->type];
}
```

and here is for table of content:

```cpp
void Cdfs(Cnode *v, string index) {
    TOC += "<li>\n";
    TOC += "<a href=\"#" + v->tag + "\">" + index + " " + v->heading + "</a>\n";
    int n = (int)v->ch.size();
    if (n) {
        TOC += "<ul>\n";
        for (int i = 0; i < n; i++) {
            Cdfs(v->ch[i], index + to_string(i + 1) + ".");
        }
        TOC += "</ul>\n";
    }
    TOC += "</li>\n";
}
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -i 'dfs' /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't define function "dfs()" in "mdtransform.hpp" !
  timeout: 2
```

### 3.7 Core Logic of Construction

With the above preparation, we can start the core logic of constrction:

```cpp
// constructor
MarkdownTransform(const std::string &filename) {
    Croot = new Cnode("");
    root = new node(nul);
    now = root;

    std::ifstream fin(filename);

    bool newpara = false;
    bool inblock = false;
    while (!fin.eof()) {
        // fetch a line from file
        fin.getline(s, maxLength);

        // processing newline except code block
        if (!inblock && isCutline(s)) {
            now = root;
            now->ch.push_back(new node(hr));
            newpara = false;
            continue;
        }

        // std::pair essentially a struct, it combines two data object
        // calculate spaces and tabs
        std::pair<int, char *> ps = start(s);

        // read next line if not in code block and no spaces and tabs
        if (!inblock && ps.second == nullptr) {
            now = root;
            newpara = true;
            continue;
        }

        // analysing the type of text
        std::pair<int, char *> tj = JudgeType(ps.second);

        // if code block
        if (tj.first == blockcode) {
            // push a empty node if in a code block
            inblock ? now->ch.push_back(new node(nul)) : now->ch.push_back(new node(blockcode));
            inblock = !inblock;
            continue;
        }

        // if in code block
        if (inblock) {
            now->ch.back()->elem[0] += string(s) + '\n';
            continue;
        }

        // if normal paragraph
        if (tj.first == paragraph) {
            if (now == root) {
                now = findnode(ps.first);
                now->ch.push_back(new node(paragraph));
                now = now->ch.back();
            }
            bool flag = false;
            if (newpara && !now->ch.empty()) {
                node* ptr = nullptr;
                for (auto i: now->ch) {
                    if (i->type == nul)
                        ptr = i;
                }
                if (ptr != nullptr)
                    mkpara(ptr);
                flag = true;
            }
            if (flag) {
                now->ch.push_back(new node(paragraph));
                now = now->ch.back();
            }
            now->ch.push_back(new node(nul));
            insert(now->ch.back(), string(tj.second));
            newpara = false;
            continue;
        }

        now = findnode(ps.first);

        // if head line
        if (tj.first >= h1 && tj.first <= h6) {
            now->ch.push_back(new node(tj.first));
            now->ch.back()->elem[0] = "tag" + to_string(++cntTag);
            insert(now->ch.back(), string(tj.second));
            Cins(Croot, tj.first - h1 + 1, string(tj.second), cntTag);
        }

        // if unordered list
        if (tj.first == ul) {
            if (now->ch.empty() || now->ch.back()->type != ul) {
                now->ch.push_back(new node(ul));
            }
            now = now->ch.back();
            bool flag = false;
            if (newpara && !now->ch.empty()) {
                node* ptr = nullptr;
                for (auto i: now->ch) {
                    if (i->type == li) ptr = i;
                }
                if (ptr != nullptr) mkpara(ptr);
                flag = true;
            }
            now->ch.push_back(new node(li));
            now = now->ch.back();
            if (flag) {
                now->ch.push_back(new node(paragraph));
                now = now->ch.back();
            }
            insert(now, string(tj.second));
        }

        // if ordered list
        if (tj.first == ol) {
            if (now->ch.empty() || now->ch.back()->type != ol) {
                now->ch.push_back(new node(ol));
            }
            now = now->ch.back();
            bool flag = false;
            if (newpara && !now->ch.empty()) {
                node* ptr = nullptr;
                for (auto i: now->ch) {
                    if (i->type == li) ptr = i;
                }
                if (ptr != nullptr) mkpara(ptr);
                flag = true;
            }
            now->ch.push_back(new node(li));
            now = now->ch.back();
            if (flag) {
                now->ch.push_back(new node(paragraph));
                now = now->ch.back();
            }
            insert(now, string(tj.second));
        }

        // if quote
        if (tj.first == quote) {
            if (now->ch.empty() || now->ch.back()->type != quote) {
                now->ch.push_back(new node(quote));
            }
            now = now->ch.back();
            if (newpara || now->ch.empty()) now->ch.push_back(new node(paragraph));
            insert(now->ch.back(), string(tj.second));
        }

        newpara = false;

    }

    // finish reading
    fin.close();

    // deep search syntax tree
    dfs(root);

    // construct table of content
    TOC += "<ul>";
    for (int i = 0; i < (int)Croot->ch.size(); i++)
        Cdfs(Croot->ch[i], to_string(i + 1) + ".");
    TOC += "</ul>";
}
```

```checker
- name: check file content
  script: |
    #!/bin/bash
    grep -i 'MarkdownTransform' /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't define construction method "MarkDownTransform()" in "mdtransform.hpp" !
  timeout: 2
```

### 3.8 Core Logic of Destruction

We created the entire syntax tree by using dynamic allocation, so we must release the relevant memory in the destructor. Furthermore, we also have Cnode and node two structures, does it means we need two different sets of release mechanism in advance? Essentially, we can use the template to solve this problem in just one function:

```cpp
// destroy all nodes
template <typename T>
void destroy(T *v) {
    for (int i = 0; i < (int)v->ch.size(); i++) {
        destroy(v->ch[i]);
    }
    delete v;
}
// destructor
~MarkdownTransform() {
    destroy<node>(root);
    destroy<Cnode>(Croot);
}
```

Until now, we finally finished all implementation, now we can build:

```bash
g++ main.cpp -std=c++11
./a.out
```

Let's open the generated `index.html`:

![image desc](https://labex.io/upload/J/Q/V/D3yhhIZBEL4x.png)

We can also click the table of content to jump where we want to.

```checker
- name: check file exist
  script: |
    #!/bin/bash
    ls  /home/labex/Code/a.out
  error: Please use 'g++ main.cpp -std=c++11' cmd to compile "main.cpp" !
  timeout: 3
- name: check file content
  script: |
    #!/bin/bash
    grep -i '~MarkdownTransform' /home/labex/Code/mdtransform.hpp
  error: Oops! We find that you didn't define destruction method "~MarkDownTransform()" in "mdtransform.hpp" !
  timeout: 2
```

## 4. Summary

In this project, we implemented a simple markdown parser. By using this parser, we generate the HTML file of markdown file, here is our project folder three:

```
src
├── a.out
├── main.cpp
├── mdtransform.hpp
├── output
│   ├── github-markdown.css
│   └── index.html
└── test.md
```

Note that our parser doesn't support all markdown syntax, if you are interested in this project, you can further implement `+` and `*` for unordered list syntax, and it only requires ten lines of changes.

## 5. Reference

1. [Markdown](http://daringfireball.net/projects/markdown/syntax)
